<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>摸着石头过河</title>
  
  <subtitle>记录和分享生活中的快乐和成长！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xingyichuan.github.io/"/>
  <updated>2019-12-25T13:28:52.117Z</updated>
  <id>https://xingyichuan.github.io/</id>
  
  <author>
    <name>xingyichuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Inventor iLogic 笔记（一）什么场景适合iLogic?</title>
    <link href="https://xingyichuan.github.io/2019/12/25/Inventor%E7%AC%94%E8%AE%B0(%E4%B8%80)%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88iLogic/"/>
    <id>https://xingyichuan.github.io/2019/12/25/Inventor%E7%AC%94%E8%AE%B0(%E4%B8%80)%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88iLogic/</id>
    <published>2019-12-25T02:34:12.000Z</published>
    <updated>2019-12-25T13:28:52.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Inventor-iLogic"><a href="#什么是Inventor-iLogic" class="headerlink" title="什么是Inventor iLogic?"></a>什么是Inventor iLogic?</h2><p><img src="/2019/12/25/Inventor%E7%AC%94%E8%AE%B0(%E4%B8%80)%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88iLogic/autodesk-inventor.jpg" alt="demo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Inventor-iLogic&quot;&gt;&lt;a href=&quot;#什么是Inventor-iLogic&quot; class=&quot;headerlink&quot; title=&quot;什么是Inventor iLogic?&quot;&gt;&lt;/a&gt;什么是Inventor iLogic?&lt;/h2&gt;&lt;p&gt;&lt;img
      
    
    </summary>
    
    
      <category term="Autodesk" scheme="https://xingyichuan.github.io/categories/Autodesk/"/>
    
      <category term="Inventor" scheme="https://xingyichuan.github.io/categories/Autodesk/Inventor/"/>
    
    
      <category term="iLogic" scheme="https://xingyichuan.github.io/tags/iLogic/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十九）缺陷的重新验证及同回归测试的区别</title>
    <link href="https://xingyichuan.github.io/2019/11/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B9%9D)%20%E7%BC%BA%E9%99%B7%E7%9A%84%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81%E5%8F%8A%E5%90%8C%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://xingyichuan.github.io/2019/11/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B9%9D)%20%E7%BC%BA%E9%99%B7%E7%9A%84%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81%E5%8F%8A%E5%90%8C%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-11-07T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:53.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们聊过《<a href="https://segmentfault.com/a/1190000020960574" target="_blank" rel="noopener">软件测试笔记（十七）回归测试的介绍和工具选择</a>》，今天要分享的是缺陷的重新验证，这个回归测试的概念很相似，但又有所不同，下面会和大家详细聊聊缺陷的重新验证和它们之间的差异。</p><h2 id="缺陷的重新验证定义"><a href="#缺陷的重新验证定义" class="headerlink" title="缺陷的重新验证定义"></a>缺陷的重新验证定义</h2><p>定义很明确：确保在早期版本中发现并发布的缺陷在当前版本中得到修复或不被修复。</p><p>更简单地说，重新测试就是在修复某个特定的错误之后对其进行测试。</p><p>例如，发布了版本1.0。在测试版本1.0时，测试发现了一些缺陷（例如，缺陷ID 1.0.1并提交到缺陷系统。测试团队测试Build1.1中的缺陷ID1.0.1，以确定缺陷是否已修复。</p><p>按照缺陷生命周期，一旦测试人员发现缺陷，就会将缺陷报告给开发团队。缺陷的状态应该是“提交”。开发团队可以接受或拒绝这个缺陷。如果开发团队接受这个缺陷，那么他们会修复它并在下一个或者几个版本中发布它(取决于缺陷的修复的难易程度)。缺陷的状态将是“准备好进行测试”。现在测试人员验证这个缺陷，以确定它是否被解决。这种测试称为重新验证测试。重新验证测试是一项计划性测试。我们使用的测试用例与我们在早期构建中使用的测试数据相同。如果没有发现缺陷，那么我们将缺陷的状态更改为“已修复”，否则我们将状态更改为“未修复”，并将缺陷重新发送给开发团队。</p><h2 id="何时执行缺陷的重新验证？"><a href="#何时执行缺陷的重新验证？" class="headerlink" title="何时执行缺陷的重新验证？"></a>何时执行缺陷的重新验证？</h2><ol><li>如果在发行说明中指定了特定的错误修复：一旦开发团队发布了新的版本，那么测试团队就必须测试已经发布的修复后的缺陷，以确保缺陷是否被修复。</li><li>当错误被拒绝时：有时，开发团队会拒绝一些由测试人员提出的缺陷，并提到缺陷的状态是“不可重现”。在这种情况下，测试人员需要重新测试同一个问题，让开发人员知道该问题是有效的和可重现的。<br> 为了避免这种情况，我们需要编写一个好的缺陷报告。请参阅《<a href="https://segmentfault.com/a/1190000020885235" target="_blank" rel="noopener">软件测试笔记（九）怎么样写才是一个好的缺陷报告？</a>》。</li></ol><h2 id="缺陷的重新验证及同回归测试的区别"><a href="#缺陷的重新验证及同回归测试的区别" class="headerlink" title="缺陷的重新验证及同回归测试的区别"></a>缺陷的重新验证及同回归测试的区别</h2><h4 id="定义不同："><a href="#定义不同：" class="headerlink" title="定义不同："></a>定义不同：</h4><ul><li><p>回归测试</p><p>  当生产代码被修改时，我们都会进行软件回归测试。通常，我们在以下情况下执行回归测试：</p><ol><li>当新功能添加到应用程序时。示例：一个网站有一个登录功能，允许用户只使用电子邮件登录。现在，新功能看起来像是“提供了一个新功能，可以使用微信登录”。</li><li>当有变更需求时。示例：从之前可用的登录页中删除“记住密码”。</li><li>当有缺陷修复时。示例：假设登录按钮在登录页面中不起作用，测试人员报告缺陷，指出登录按钮已损坏。一旦开发人员修复了这个缺陷，测试人员就会测试它，以确保登录按钮是否按照预期的结果工作。同时测试人员回归测试与登录按钮相关的其他功能。</li><li>当出现性能问题修复时。示例：加载主页需要5秒钟将加载时间缩短到2秒，我们需要保证主页相关的回归测试都能正常通过。</li><li>当环境发生变化时。示例：将数据库从MySQL更新为Oracle。</li><li>当有代码重构的时。</li></ol></li><li><p>缺陷的重新验证<br>  以确保在早期生成中发现并发布的缺陷在当前生成中是否得到修复。</p></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面以一个登陆界面作为我们比较两者的区别的案例。首先，我们假设两种情况：<br>案例1：登录页面-登录按钮不起作用（错误）<br>案例2：登录页面-添加了“保持登录”复选框（新功能）</p><p>在案例1中，登录按钮不起作用，所以测试人员报告一个缺陷。一旦修复了这个错误，测试人员就会测试它，以确保登录按钮是否按照预期的结果工作。<br>在前面，也有一篇关于《<a href="https://segmentfault.com/a/1190000020852793" target="_blank" rel="noopener">软件测试笔记（六）缺陷报告应该涵盖哪些内容</a>》的文章，可以帮助更好的提交缺陷。</p><p>在案例2中，测试人员测试新特性以确保新特性（保持登录）是否按预期工作。<br>案例1正在缺陷的重新验证中。在这里，测试人员使用错误报告中提到的重现步骤，重新测试在早期构建中发现的错误。</p><p>同样在案例1中，测试人员测试与登陆按钮相关的其他功能，我们称之为回归测试。</p><p>在案例2中，测试人员测试新功能（保持登录状态）并测试相关功能。在测试新特性的同时测试相关的功能将进行回归测试。</p><p>另一个例子：</p><p>想象一下，一个正在测试的应用软件有三个模块，即管理、购买和财务。财务模块依赖于采购模块。如果测试人员在购买模块上发现一个缺陷并提交。缺陷修复后，测试人员需要重新测试，以验证与购买相关的缺陷是否修复，并且测试人员还需要进行回归测试，以测试依赖于购买模块的财务模块。</p><p>回归和复测之间的一些其他差异：<br>对失败的测试用例进行缺陷的重新验证，而对通过的测试用例进行回归测试。<br>缺陷的重新验证确保原始缺陷已被纠正，而回归测试确保没有意外的副作用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里大家可以了解了缺陷的重新验证的定义，以及什么时候我们需要执行缺陷的重新验证。同时也对比了非常会让人混淆的回归测试，以及其应用的场景，希望对大家有所帮助。如果大家关于缺陷的重新验证及同回归测试有什么想法，也请留言区回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面我们聊过《&lt;a href=&quot;https://segmentfault.com/a/1190000020960574&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十八）测试方案和测试用例的区别</title>
    <link href="https://xingyichuan.github.io/2019/11/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E5%85%AB)%20%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E5%92%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://xingyichuan.github.io/2019/11/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E5%85%AB)%20%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E5%92%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-11-06T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:44.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在测试的面试过程中，经常会有面试官问“测试方案和测试用例的区别”。两者都是测试的产出，想要区别两者可以从下面的这些方面着手。</p><h2 id="测试方案的定义"><a href="#测试方案的定义" class="headerlink" title="测试方案的定义"></a>测试方案的定义</h2><p>测试方案给出了我们必须测试的内容。测试场景就像一个抽象的测试用例。</p><p>测试方案回答“要测试什么”。</p><p>假设我们需要测试应用程序登录页面的功能。登录页面功能的测试方案如下：</p><p>测试方案示例：验证登录功能</p><h2 id="测试用例的定义"><a href="#测试用例的定义" class="headerlink" title="测试用例的定义"></a>测试用例的定义</h2><p>测试用例是一个测试方案的可以是正向的或者是逆向的可执行步骤的集合，包含一组前置条件、测试数据、预期结果、后置条件和实际结果。</p><p>测试用例回答“如何测试”。</p><p>假设我们需要测试应用程序登录页面的功能。上述登录页功能的测试用例如下：</p><p>测试用例示例：</p><ol><li>测试用例1：输入有效的用户名和密码</li><li>测试用例2：输入有效用户名和无效密码</li><li>测试用例3：输入无效用户名和有效密码</li><li>测试用例4：输入无效的用户名和密码</li></ol><h2 id="测试方案和测试用例的区别"><a href="#测试方案和测试用例的区别" class="headerlink" title="测试方案和测试用例的区别"></a>测试方案和测试用例的区别</h2><table><thead><tr><th>测试方案</th><th>测试用例</th></tr></thead><tbody><tr><td>测测试方案是一句话，但它与多个测试用例相关联</td><td>测试用例由测试用例名称、前置条件、测试步骤、预期结果和后置条件组成</td></tr><tr><td>测试场景指导用户“测试什么”</td><td>测试用例指导用户“如何测试”</td></tr><tr><td>测试方案的目的是测试软件的端到端功能</td><td>测试用例的目的是通过执行一组步骤来验证测试方案</td></tr><tr><td>在敏捷测试中，测试方案则相对更加适应</td><td>创建测试用例对于没有固定测试人员的项目很重要</td></tr><tr><td>因为相对抽象，所以在需求变更后，相对比较好维护</td><td>软件的页面调整，新功能的添加或者需求变更，导致维护测试用例难度增加</td></tr><tr><td>需要花费相对较少的测试时间</td><td>与测试方案相比，往往需要花费更多的测试时间</td></tr><tr><td>需要相对较小的资源来创建和执行测试用例</td><td>需要更多的资源来创建和执行测试用例</td></tr><tr><td>它可以以灵活的方式，测试端到端功能</td><td>它的测试更加全面</td></tr><tr><td>它会衍生出测试用例</td><td>它通常是由测试方案衍生出来的</td></tr><tr><td>它是相对抽象的测试</td><td>它是相对具体的测试</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，大家应该对测试方案和测试用例的定义，以及两者的区别和使用场景有了自己的理解。当然实际测试中，我们也会同时使用测两者，为了确保稳定的、高覆盖率的测试计划。最好的做法是编写测试方案，然后转到测试用例。尽管这是一个最佳实践，但在当今的敏捷时代，大多数公司更喜欢测试场景。在敏捷时代，为了节省时间，测试用例正在被测试方案所取代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在测试的面试过程中，经常会有面试官问“测试方案和测试用例的区别”。两者都是测试的产出，想要区别两者可以从下面的这些方面着手。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十七）冒烟测试VS可用性测试</title>
    <link href="https://xingyichuan.github.io/2019/11/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%83)%20%E5%86%92%E7%83%9F%E6%B5%8B%E8%AF%95VS%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/"/>
    <id>https://xingyichuan.github.io/2019/11/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%83)%20%E5%86%92%E7%83%9F%E6%B5%8B%E8%AF%95VS%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/</id>
    <published>2019-11-05T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:59.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>冒烟测试和可用性测试都有自己的目标和执行的优先顺序。这两种类型的测试对于项目的成功起着关键的作用。对于新人来说，这两种类型通常会弄混淆。希望在本文结束时，可以对理智和烟雾测试有一个清晰的概念。</p><h2 id="什么是冒烟测试"><a href="#什么是冒烟测试" class="headerlink" title="什么是冒烟测试"></a>什么是冒烟测试</h2><p>冒烟测试是为了确保我们从开发团队收到的软件功能是否可测试。也称为“第0天”测试（先导测试），这是在“构建软件功能级别”完成的。</p><p>如果对应的关键功能不起作用或关键错误尚未修复时，在不浪费测试时间的前提现，来简单地测试整个应用程序是有帮助的。在这里，我们关注的重点是主要和核心软件工作流程。</p><h4 id="如何进行冒烟测试？"><a href="#如何进行冒烟测试？" class="headerlink" title="如何进行冒烟测试？"></a>如何进行冒烟测试？</h4><p>为了进行冒烟测试，我们不必编写特定的测试用例。我们只是从已经编写好的测试用例中，选择必要的测试用例即可。</p><p>我们真的为所有测试类型编写测试用例吗？在本文中，我们对选择测试类型来编写测试用例给出了明确的想法。</p><p>如前所述，在冒烟测试中，我们主要关注的是核心应用程序的工作流程。因此，我们从我们的测试集合中选择测试用例，它涵盖了应用程序的主要功能。一般来说，我们选择的测试用例数量最少，执行时间不会超过半小时。</p><p>假设您正在为一个电子商务网站工作。当发布一个新的构建进行测试时，作为一个测试人员，您必须确保核心功能是否正常工作。因此，您尝试访问电子商务网站，并添加一个项目到您的购物车下订单。这是大多数电子商务网站的主要流程。如果此流有效，则可以说此生成已通过。您可以继续在同一个构建上进行功能测试。</p><h4 id="冒烟测试需要自动化吗？"><a href="#冒烟测试需要自动化吗？" class="headerlink" title="冒烟测试需要自动化吗？"></a>冒烟测试需要自动化吗？</h4><p>是的，我们需要它。它节省了很多测试时间假设你有50-100个冒烟测试用例。为了执行这些50-100个测试用例，大约需要4-6个小时的时间。如果您有这些测试用例的自动化脚本，那么您可以在发布构建后执行它们，并在手动执行冒烟测试测试用例所花费的时间内确认是否通过了冒烟测试。因此，大多数团队都自动化了冒烟测试用例。</p><h2 id="什么是可用性测试"><a href="#什么是可用性测试" class="headerlink" title="什么是可用性测试"></a>什么是可用性测试</h2><p>可用性测试在发布阶段进行，以检查应用程序的主要功能，而不必深入。它也被称为回归测试的子集。这是在“发布级别”完成的。</p><p>有时由于发布时间限制，无法对构建进行严格的回归测试，而可用性测试则通过检查主要功能来完成这一部分。</p><p>大多数时候，我们没有足够的时间来完成整个测试。特别是在敏捷方法论中，我们会受到产品负责人的压力，要求在几小时内或一天结束时完成测试。在这种情况下，我们选择可用性测试。在这种情况下，可用性测试起着关键作用。</p><h4 id="如何进行可用性测试？"><a href="#如何进行可用性测试？" class="headerlink" title="如何进行可用性测试？"></a>如何进行可用性测试？</h4><p>和冒烟测试一样，我们不为可用性测试编写单独的测试用例。我们只是从已经编写好的测试用例中选择必要的测试用例。</p><p>它是回归测试的一个子集。当涉及到可用性测试的时候，主要考虑的是功能能否按照需求文档的要求工作。</p><p>假设你在一个电子商务网站工作。发布了一个与搜索功能相关的新功能。在这里，你的主要精力应该放在搜索功能上。一旦你确定搜索功能运行良好，然后你转移到其他主要功能，如支付流。</p><h4 id="可用性测试需要自动化吗？"><a href="#可用性测试需要自动化吗？" class="headerlink" title="可用性测试需要自动化吗？"></a>可用性测试需要自动化吗？</h4><p>是的，我们也需要它。它节省了很多测试时间假设你有50-100个可用性测试用例。那么您可以在收到稳定构建后执行它们，而不是人为去手动执行这些可用性测试，而是把精力放在其他的测试上去。</p><h2 id="冒烟测试VS可用性测试"><a href="#冒烟测试VS可用性测试" class="headerlink" title="冒烟测试VS可用性测试"></a>冒烟测试VS可用性测试</h2><p>在一个项目的开发发布过程中，开发团队构建软件给测试人员测试，测试拿到构建完成的软件后，首先检查产品的基本状况和功能，我们称之为冒烟测试。如果测试人员，在冒烟测试后觉得产品可以延展更多的测试，例如登录页面包含管理员，员工和一般用户。测试人员针对主要的功能进行测试而不延展更多的测试，我们称之为可用性测试。</p><table><thead><tr><th>冒烟测试</th><th>可用性测试</th></tr></thead><tbody><tr><td>进行冒烟测试，以确保测试人员从开发团队收到的构建软件是否可测试</td><td>在发布阶段进行可用性测试，以检查应用程序的主要功能，而不必深入</td></tr><tr><td>由开发人员和测试人员共同执行</td><td>由测试人员单独进行的</td></tr><tr><td>以端对端的方式测试整个应用</td><td>测试整个应用某个特定组件或者功能</td></tr><tr><td>构建软件可能是不稳定的</td><td>构建软件相对稳定的</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>冒烟测试和可用性测试都是回归测试的子集，具体的目标不尽相同，冒烟测试为了确保构建的稳定，可用，可用性测试则是保证目标功能可以正常使用。希望上面的内容可以帮助理清冒烟测试和可用性测试的区别。如果有关于冒烟测试和可用性测试的相关话题，也请大家评论区留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;冒烟测试和可用性测试都有自己的目标和执行的优先顺序。这两种类型的测试对于项目的成功起着关键的作用。对于新人来说，这两种类型通常会弄混淆。希望
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十六）单元测试 VS 集成测试 VS 系统测试</title>
    <link href="https://xingyichuan.github.io/2019/11/04/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E5%85%AD)%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20VS%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%20VS%20%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/"/>
    <id>https://xingyichuan.github.io/2019/11/04/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E5%85%AD)%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20VS%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%20VS%20%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/</id>
    <published>2019-11-04T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:56.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介绍了集成测试《<a href="https://segmentfault.com/a/1190000020890154" target="_blank" rel="noopener">如何做到有效的集成测试？</a>》，后来有小伙伴私信问，能具体列举出单元测试 VS 集成测试 VS 系统测试之间的区别和应用场景。那么这次我们就把这个比较给补上。</p><h2 id="单元测试-VS-集成测试"><a href="#单元测试-VS-集成测试" class="headerlink" title="单元测试 VS 集成测试"></a>单元测试 VS 集成测试</h2><table><thead><tr><th>单元测试</th><th>集成测试</th></tr></thead><tbody><tr><td>单元测试是软件测试中第一级测试</td><td>集成测试是软件测试中第二级测试</td></tr><tr><td>每一个组件都是一个单独测试的对象</td><td>集成组件被视为单独测试的对象</td></tr><tr><td>测试目标是确保单独的组件可以正常工作</td><td>目的是测试多个单元模块的集成</td></tr><tr><td>测试结果用来评价每一个被测组件</td><td>它检查模块集成后，外部接口和系统的正常工作、接口是否可靠性</td></tr><tr><td>单元测试的范围仅限于被测试的特定单元</td><td>与单元测试相比，集成测试的范围更广，它包含多个模块</td></tr><tr><td>它没有其他类型</td><td>它分为以下几种方法：1.自下而上的整合方法 2.自上而下的集成方法 3.大爆炸方法 4.混合方法</td></tr><tr><td>它在代码级别执行</td><td>它在接口层执行</td></tr><tr><td>它是基于可重用的测试用例来实现的</td><td>它是基于桩和驱动来实现的</td></tr><tr><td>通常它属于白盒测试范畴</td><td>它可以同时使用白盒和黑盒测试方法</td></tr><tr><td>它是由开发或者测试开发完成</td><td>它由测试人员或开发人员执行</td></tr></tbody></table><h2 id="集成测试-VS-系统测试"><a href="#集成测试-VS-系统测试" class="headerlink" title="集成测试 VS 系统测试"></a>集成测试 VS 系统测试</h2><table><thead><tr><th>集成测试</th><th>系统测试</th></tr></thead><tbody><tr><td>它比较关注细节（low level）</td><td>它是比较关注用户需求（high level）</td></tr><tr><td>紧接着它的就是系统测试</td><td>紧接着它的就是用户验收测试</td></tr><tr><td>在它之前执行的单元测试</td><td>在它之前执行的集成测试</td></tr><tr><td>它分为以下几种方法：1.自下而上的整合方法 2.自上而下的集成方法 3.大爆炸方法 4.混合方法</td><td>它分为以下几种方法：1.回归测试 2.心智检查测试 3.可用性测试 4.负载测试 5.性能测试 6.维护测试</td></tr><tr><td>测试人员执行功能测试以验证多个模块的交互</td><td>测试人员执行功能测试和非功能测试，以评估功能性、可用性、性能测试等。。。</td></tr><tr><td>测试两个多模块之间是否有效的交互</td><td>测试产品是否按照用户期望和需求文档执行</td></tr><tr><td>它可以由测试人员和开发人员执行</td><td>它由测试人员执行</td></tr><tr><td>在多模块的接口上进行测试</td><td>在完整的软件上进行测试</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单元测试 VS 集成测试 VS 系统测试，三者都引入到了整个测试的生命周期内。对于三者的区别，主要集中表现在测试阶段的不同，测试的目标不同及测试的方法不同。如果大家有新的补充，也请留言区回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前介绍了集成测试《&lt;a href=&quot;https://segmentfault.com/a/1190000020890154&quot; target
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十五）白盒测试和黑盒测试的区别</title>
    <link href="https://xingyichuan.github.io/2019/11/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%BA%94)%20%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%92%8C%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://xingyichuan.github.io/2019/11/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%BA%94)%20%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%92%8C%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-11-03T02:00:00.000Z</published>
    <updated>2019-12-04T15:22:12.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们聊过《<a href="https://segmentfault.com/a/1190000020895151" target="_blank" rel="noopener">软件测试笔记（十一）自动化测试和手动测试的选择</a>》，有些朋友和我聊到在测试里面还有类似的一些概念，比如白盒测试和黑盒测试。今天就大家分享下我对这两种测试的理解。</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>它是根据软件需求和规范创建测试场景/案例，按照需求文档里面定义的行为及规范进行输入并且检查输出的测试。</p><p>测试人员在不查看内部代码结构的情况下，评估被测软件的功能。它可以应用于软件测试的各个层次，如单元、集成、系统和验收测试。</p><p>因为不查看源码，所以测试人员只对应用程序的功能部分执行测试，以确保软件的行为符合预期，所以是基于行为的测试。</p><h4 id="黑盒测试的常用的一些技术"><a href="#黑盒测试的常用的一些技术" class="headerlink" title="黑盒测试的常用的一些技术"></a>黑盒测试的常用的一些技术</h4><ul><li>等价划分：等价划分也称为等价类划分法。在等价划分法中，软件的输入被划分为期望表现出相似行为的组，因此它们很可能以相同的方式被输入。因此，从每个组中选择一个输入来设计测试用例。</li></ul><ul><li>边界值分析：边界值分析（BVA）是在测试有效和无效分区的边界值的基础上进行的。每个等价分区边缘的行为比分区内的行为更加容易出现缺陷，因此边界是测试可能产生缺陷的区域。</li></ul><ul><li>决策表：决策表又称因果表。这种测试技术适用于输入之间具有逻辑关系的功能。在决策表技术中，我们处理输入的组合。为了识别决策表的测试用例，我们可以查看它的条件和输出。</li></ul><ul><li>状态转换：使用状态转换测试，我们从需要测试的不同系统转换的应用程序中选择测试用例。当应用程序为相同的输入提供不同的输出时，我们可以应用这个方法，这取决于在以前的状态中发生了什么。</li></ul><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>白盒测试是基于应用程序内部的代码结构在白盒测试中，系统的内部视角以及编程技巧被用来设计测试用例这种测试通常在单元级别进行。</p><h4 id="白盒测试的常用的一些技术"><a href="#白盒测试的常用的一些技术" class="headerlink" title="白盒测试的常用的一些技术"></a>白盒测试的常用的一些技术</h4><ul><li><p>语句覆盖率：它是一种常用的测试覆盖方式，它衡量被测代码中每个语句是够被执行到了。当然前提条件是可执行代码，类似的注释，头文件，空行，等是无法被覆盖的。通常它考虑的是代码覆盖的行数，而不考虑其内部的逻辑处理，所以测试效果不太明显。</p><p>  <code>int divide(int a, int b)  {  return a / b;  }</code><br>  假设我们的测试用例是：<br>  <code>TeseCase: a = 10, b = 5</code><br>  那么它的语句覆盖率是100%，但是除零的问题却没有表现出来。所以我们引入了其他的测试覆盖率。</p></li></ul><ul><li><p>分支覆盖率：又称判定覆盖率，它是指源码中每个判断的取真分支和取假分支至少经历一次，即判断的真假均曾被满足。例如下图就是一个关于分支覆盖的一个设计。</p><p>  <img src="/2019/11/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%BA%94)%20%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%92%8C%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/bVbzQhP" alt="1018115-20161008171000176-82131142.png"></p></li><li><p>路径覆盖率：它包含所有可能的控制路径，在路径覆盖技术中取零、一次和多个（理想，最大）项的所有循环路径，基于程序设计的逻辑复杂性度量来准备测试用例。所以可以认为是分支覆盖和语句覆盖的集合。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>黑盒测试</th><th>白盒测试</th></tr></thead><tbody><tr><td>不查看内部代码结构</td><td>了解程序内部的代码结构</td></tr><tr><td>按照根据软件需求和规范设计</td><td>按照程序内部逻辑设计</td></tr><tr><td>涉及到单元、集成、系统和验收测试</td><td>涉及到单元、集成测试</td></tr><tr><td>测试人员不需要程序经验</td><td>需要有一定的程序经验</td></tr><tr><td>可以是手动或者是自动化测试</td><td>可以是手动或者是自动化测试</td></tr></tbody></table><p>概括的来说，黑盒测试和白盒测试的侧重点是不一样的。黑盒更关注的是软件实现的功能是否按照需求文档来，而白盒测试更加关注程序内部的逻辑是不是正确。如果大家有其他的看法或者想法，也请留言区一起讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面我们聊过《&lt;a href=&quot;https://segmentfault.com/a/1190000020895151&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十四）回自动化测试和手动测试的选择</title>
    <link href="https://xingyichuan.github.io/2019/11/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E5%9B%9B)%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%92%8C%E6%89%8B%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <id>https://xingyichuan.github.io/2019/11/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E5%9B%9B)%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%92%8C%E6%89%8B%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%89%E6%8B%A9/</id>
    <published>2019-11-02T02:00:00.000Z</published>
    <updated>2019-12-04T15:22:08.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件测试是为了评估软件应用程序的功能，以确定开发的软件是否满足指定的要求，并确定缺陷，以确保产品无缺陷，从而生产出高质量的产品。而软件测试分为手工测试和自动化测试两大类。手工测试和自动化测试都有各自的优点和缺点，而且我们知道项目都有很关键的要素：质量、成本和时间，任何项目的目标都是获得高质量的产出，同时控制完成项目所需的成本和时间，所以了解手工测试和自动化测试以及何时使用手工测试和何时使用自动化测试之间的区别是非常必要的。</p><p><img src="/2019/11/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E5%9B%9B)%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%92%8C%E6%89%8B%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%89%E6%8B%A9/bVbzPXb" alt="robotic-automation-for-companies.jpg"></p><h2 id="手动测试"><a href="#手动测试" class="headerlink" title="手动测试"></a>手动测试</h2><p>对软件进行手工测试以发现缺陷的过程。测试人员是站在用户的视角，并确保所有功能都按照需求文档中那样工作。在这个过程中，测试人员执行测试用例并在不使用任何自动化工具的情况下手动生成报告。</p><h4 id="手动测试类型"><a href="#手动测试类型" class="headerlink" title="手动测试类型"></a>手动测试类型</h4><ul><li>黑盒测试：黑盒测试是一种软件测试方法，测试人员在测试中测试被测软件的功能，而不查看内部代码结构。这可以应用于软件测试的各个层次，如单元、集成、系统和验收测试。</li><li>白盒测试：它是基于应用程序内部的代码结构的测试。在白盒测试中，系统的内部视角以及编程技巧被用来设计测试用例。这种测试通常在单元级别进行。</li><li>单元测试：也称模块测试或组件测试。这样做是为了检查源代码的单个单元或模块是否正常工作。通常它是由开发人员在开发人员的环境中完成的。</li><li>系统测试：测试完整的应用程序，以评估系统是否符合其客户的需求，我们称之为系统测试，也称为端到端测试。目标是已完成的系统，以确保软件是否按预期工作。</li><li><a href="https://segmentfault.com/a/1190000020890154" target="_blank" rel="noopener">集成测试</a>：集成测试是测试两个软件单元之间接口的过程。集成测试有三种方式。大爆炸法，自上而下法，自下而上法。</li><li>验收测试：通常它由最终用户和测试人员一起完成的，以验证软件的功能是否按照用户需求来实现。进行测试后，客户可以接受或拒绝所提供的软件功能。验收测试的类型有Alpha、Beta和Gamma测试。</li></ul><p>当然还有许多的手动测试种类，请查考《<a href="https://segmentfault.com/a/1190000020783344" target="_blank" rel="noopener">软件测试笔记（三）多种多样的测试类型</a>》。</p><h4 id="何时适用手动测试"><a href="#何时适用手动测试" class="headerlink" title="何时适用手动测试"></a>何时适用手动测试</h4><ul><li>探索性测试：由行业专家进行探索性测试。他们通过探索应用程序的功能来执行测试，而不了解详细的需求。</li><li>可用性测试：验证软件是否用户友好，是否被最终用户舒适地使用。主要重点是检查最终用户是否能够轻松理解和操作软件。一个好的软件应该是自我探索的，具有引导性的，并且不需要太多的培训来操作它。</li><li>随机测试：测试人员在不遵循任何文档和测试设计技术的情况下随机测试软件。如果试人员的知识非常丰富，则主要执行此类测试，测试人员在没有任何测试用例或业务需求文档的情况下随机测试应用程序。</li></ul><h4 id="何时使用手动测试，而非自动化测试"><a href="#何时使用手动测试，而非自动化测试" class="headerlink" title="何时使用手动测试，而非自动化测试"></a>何时使用手动测试，而非自动化测试</h4><ol><li>当项目处于初始开发阶段时，测试框架搭建完成前。</li><li>当测试用户界面。</li><li>当需要进行探索性或随机性测试。</li><li>如果项目是短期的，与手动测试相比，编写脚本和搭建测试框架非常耗时的时候。</li><li>如果测试用例不能自动执行验证码示例。</li></ol><h4 id="手动测试的优劣"><a href="#手动测试的优劣" class="headerlink" title="手动测试的优劣"></a>手动测试的优劣</h4><h5 id="优："><a href="#优：" class="headerlink" title="优："></a>优：</h5><ol><li>适用范围广，可以在各种软件上进行手动测试。</li><li>对于短生命周期产品更可取。</li><li>新设计的测试用例应该手动执行，以确保用例的正确性。</li><li>应用程序在自动化之前必须手动测试。</li><li>在需求频繁变化的项目和GUI不断变化的产品。</li><li>与自动化测试相比，它的初始投资更便宜。</li><li>开始手动测试所需的时间和费用更少。</li><li>它允许测试人员执行随机测试。</li><li>测试人员没有必要了解自动化工具和框架。</li></ol><h5 id="劣："><a href="#劣：" class="headerlink" title="劣："></a>劣：</h5><ol><li>手工测试主要是在做回归测试时耗时，而且重复性很大。</li><li>与自动化测试相比，手动测试不太可靠，因为有人的影响。所以总会有人为因素导致的一些错误。</li><li>从长远来看，相比于自动化测试代价更高。</li><li>无法重用，因为无法记录整个测试过程。</li></ol><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>自动化测试是使用自动化工具来发现软件缺陷的测试过程。在这个过程中，自动化工具会自动执行测试脚本并生成结果。一些最流行的自动化测试工具是QTP、Selenium Webdriver，Jmeter, TC等。</p><p>常用的自动化工具：</p><ol><li>HP QTP</li><li>Selenium</li><li>LoadRunner</li><li>SilkTest</li><li>TestComplete</li><li>WinRunner</li><li>Jmeter</li></ol><h4 id="何时适用自动化测试"><a href="#何时适用自动化测试" class="headerlink" title="何时适用自动化测试"></a>何时适用自动化测试</h4><ul><li>回归测试：对一个已经测试过的缺陷，在修改后进行的重复测试，目的是用于发现由于软件或其他相关或不相关的软件组件的变化而引入的任何缺陷。回归测试非常适合做自动化测试，因为软件经常更改代码，而且需要进行及时的测试。</li><li>性能测试：测试软件的速度、可伸缩性和稳定性。性能是指实现满足项目或产品性能目标的响应时间、吞吐量和资源利用率级别。它非常适合自动化测试。</li></ul><p>可以同时进行手动和自动化测试的测试类型：</p><ul><li>系统测试：测试软件是否符合其指定的要求实现，也称端到端测试。目标是验证已完成的系统，以确保应用程序是否按预期工作。</li><li>单元测试：单元测试也称为模块测试或组件测试。为了检查代码的单元或模块是否正常工作。通常由开发人员在开发人员的环境中完成的。</li><li>验收测试：通常它由最终用户和测试人员一起完成的，以验证软件的功能是否按照用户需求来实现。进行测试后，客户可以接受或拒绝所提供的软件功能。验收测试的类型有Alpha、Beta和Gamma测试。</li></ul><h4 id="哪些场景不适合自动化测试"><a href="#哪些场景不适合自动化测试" class="headerlink" title="哪些场景不适合自动化测试"></a>哪些场景不适合自动化测试</h4><ul><li>探索性测试</li><li>用户界面测试</li><li>随机测试</li></ul><h4 id="何时使用自动化测试，而非手动测试"><a href="#何时使用自动化测试，而非手动测试" class="headerlink" title="何时使用自动化测试，而非手动测试"></a>何时使用自动化测试，而非手动测试</h4><ul><li>处理重复和耗时的任务</li><li>并发测试</li><li>非功能性测试，如负载、性能、压力测试</li><li>避免人为错误</li></ul><h4 id="自动化测试的优劣"><a href="#自动化测试的优劣" class="headerlink" title="自动化测试的优劣"></a>自动化测试的优劣</h4><h5 id="优：-1"><a href="#优：-1" class="headerlink" title="优："></a>优：</h5><ol><li>自动化测试的执行速度更快。</li><li>从长远来看，它比手工测试便宜。</li><li>自动化测试更可靠。</li><li>自动化测试可扩展性好和更通用。</li><li>用于回归测试。</li><li>可重用，因为自动化过程可以被记录。</li><li>它不需要人为干预。测试脚本可以在无人参与的情况下运行。</li><li>它有助于提高测试覆盖率。</li></ol><h5 id="劣：-1"><a href="#劣：-1" class="headerlink" title="劣："></a>劣：</h5><ol><li>仅推荐用于大型，稳定的产品。</li><li>自动化测试最初费用很昂贵。</li><li>大多数自动化工具都很昂贵，当然除开源软件外。</li><li>它会有有一些限制，例如处理验证码，获取ui的视觉方面的信息。</li><li>需求反复变化时。</li><li>不是所有的工具都支持各种测试如windows、web、移动性、性能/负载测试。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>自动化测试</th><th>手动测试</th></tr></thead><tbody><tr><td>自动化测试更可靠。每次执行相同的操作。它消除了人为犯错误的风险。</td><td>手动测试相对不太可靠由于可能会出现人为失误，人工检测也有可能不准确。</td></tr><tr><td>自动化测试初期投资较高。测试工具需要投资从长远来看，它比手动的便宜。与手工测试相比，从长远来看，性价比更高。</td><td>手工测试的初始投资小于自动化。人力资源需要投资。从长远来看，与自动化测试相比，性价比更低。</td></tr><tr><td>当我们进行回归测试时，自动化测试则是非常有意义的。</td><td>如果测试只需要运行一次或两次，那么手动测试是实用的选择，在这种情况下，测试用例不会重复运行。</td></tr><tr><td>执行是通过软件工具完成的，因此它比手动测试更快，并且与手动测试相比需要更少的人力资源。</td><td>测试用例的执行非常耗时，需要更多的人力资源</td></tr><tr><td>不可能进行探索性测试</td><td>可以进行探索性测试</td></tr><tr><td>性能测试如负载测试、压力测试等是自动化测试的选择。</td><td>手动化的性能测试不是一个好的选择</td></tr><tr><td>自动化测试可以并行完成，减少测试执行时间。</td><td>在手动测试中并行执行测试用例不是一件容易的事情。我们需要更多的人力资源来做到这一点，并且变得更加昂贵。</td></tr><tr><td>它可以并行完成，减少测试执行时间。</td><td>在手动测试中并行执行测试用例不是一件容易的事情。我们需要更多的人力资源来做到这一点，并且变得更加昂贵。</td></tr><tr><td>需要一些脚本方面的知识</td><td>通常不需要脚本知识</td></tr><tr><td>集成到CI/CD（持续部署/发布）很方便</td><td>无法集成到CI/CD（持续部署/发布）</td></tr><tr><td>人工干预不多，所以做用户界面测试效果不好</td><td>它涉及到人工干预，所以进行用户界面测试是非常有效的</td></tr></tbody></table><p>不管黑猫白猫，抓到老鼠的就是好猫。在测试中也是同样，不管自动化测试和手动测试，能发现缺陷，最合适的就是好的测试方法。希望上面手动测试和自动化测试的区别和适用范围可以帮助大家找到合适的测试方法。如果大家有感兴趣的话题和相关感受，也请回复到评论中和大家一起分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;软件测试是为了评估软件应用程序的功能，以确定开发的软件是否满足指定的要求，并确定缺陷，以确保产品无缺陷，从而生产出高质量的产品。而软件测试分
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十三）回归测试的介绍和工具选择</title>
    <link href="https://xingyichuan.github.io/2019/11/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%89)%20%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/"/>
    <id>https://xingyichuan.github.io/2019/11/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%89)%20%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/</id>
    <published>2019-11-01T02:00:00.000Z</published>
    <updated>2019-12-04T15:22:05.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在测试阶段，在每次迭代的时候，我们需要回归检验下前期完成的功能，来保证新的提交没有导致系统功能的衰退。所以回归测试在整个测试的生命周期中起到了非常重要的作用。</p><h2 id="回归测试的定义"><a href="#回归测试的定义" class="headerlink" title="回归测试的定义"></a>回归测试的定义</h2><p>在新功能发布后，对已经测试的程序功能进行重复测试，以发现由于正在测试的软件或其他相关或不相关的软件组件的更改而引入或发现的任何缺陷。</p><p>简单地说，我们通过对新发布后的应用程序功能重新执行测试来进行回归，以评估修改后的代码是否破坏了先前工作的任何东西。每当我们修改应用程序时，我们都应该进行回归测试。</p><p>回归测试使开发人员确信，在修改生产代码之后，没有任何功能被破坏。它确保没有意外的副作用。</p><h2 id="何时去做回归测试？"><a href="#何时去做回归测试？" class="headerlink" title="何时去做回归测试？"></a>何时去做回归测试？</h2><p>当生产代码被修改时，我们都会进行软件回归测试。通常，我们在以下情况下执行回归测试：</p><ol><li>当新功能添加到应用程序时。示例：一个网站有一个登录功能，允许用户只使用电子邮件登录。现在，新功能看起来像是“提供了一个新功能，可以使用微信登录”。</li><li>当有变更需求时。示例：从之前可用的登录页中删除“记住密码”。</li><li>当有缺陷修复时。示例：假设登录按钮在登录页面中不起作用，测试人员报告缺陷，指出登录按钮已损坏。一旦开发人员修复了这个缺陷，测试人员就会测试它，以确保登录按钮是否按照预期的结果工作。同时测试人员回归测试与登录按钮相关的其他功能。</li><li>当出现性能问题修复时。示例：加载主页需要5秒钟将加载时间缩短到2秒，我们需要保证主页相关的回归测试都能正常通过。</li><li>当环境发生变化时。示例：将数据库从MySQL更新为Oracle。</li><li>当有代码重构的时。</li></ol><p>我们已经了解了什么是回归，什么时候做回归。现在让我们看看怎么做。</p><h2 id="回归测试如何做？"><a href="#回归测试如何做？" class="headerlink" title="回归测试如何做？"></a>回归测试如何做？</h2><p>回归测试通常非常繁琐和耗时。我们在每次部署后都会进行回归，因此自动化测试用例比每次手动运行测试用例更容易。如果我们有数千个测试用例，那么最好为我们在每个构建上集成所做的自动化测试脚本(回归测试)。</p><p>自动化回归测试是最佳实践，可以节省大量时间并在夜间运行构建。</p><h3 id="回归测试的工具"><a href="#回归测试的工具" class="headerlink" title="回归测试的工具"></a>回归测试的工具</h3><h4 id="Ranorex-付费-："><a href="#Ranorex-付费-：" class="headerlink" title="Ranorex(付费)："></a><a href="https://www.ranorex.com/" target="_blank" rel="noopener">Ranorex</a>(付费)：</h4><p>Ranorex Studio是一个集桌面、移动和web于一体的自动化测试工具，受到全球4000多家公司的信赖该应用程序提供了无代码测试自动化，使初学者能够直接测试，以及一个完整的IDE。</p><pre><code>特点：1.  可靠的对象标识，即使对于具有动态id的web元素也是如此。2.  可共享对象存储库。3.  使用可重用代码模块减少测试维护。4.  跨平台和跨浏览器测试。5.  使用内置的Selenium WebDriver在Selenium Grid上并行测试或分发。6.  可定制，易于阅读的测试报告。7.  启用视频报告以查看在不重新运行测试的情况下导致测试失败的原因。8.  与完整的测试工具链集成：Azure DevOps、Jira、Jenkins、TestRail、Git等等。</code></pre><h4 id="Selenium（开源）"><a href="#Selenium（开源）" class="headerlink" title="Selenium（开源）:"></a><a href="http://www.seleniumhq.org/" target="_blank" rel="noopener">Selenium</a>（开源）:</h4><p>Selenium可能是Web应用程序最流行的开源测试自动化框架。Selenium起源于2000年代，经过十多年的发展，已经成为Web自动化测试人员的首选自动化框架。Selenium已经成为Katalon Studio、Watir、dragor和Robot framework等其他开源测试自动化工具的核心框架。</p><p>Selenium支持多种系统环境（Windows、Mac、Linux）和浏览器（Chrome、Firefox、IE和Headless浏览器）它的脚本可以用各种编程语言编写，如Java、Groovy、Python、C#、PHP、Ruby和Perl。虽然对测试人员具有灵活性，他们可以编写复杂的测试脚本，以满足不同级别的复杂性，但它需要提高编程技巧和努力来构建自动化框架和库以满足特定测试需求。</p><h4 id="UFT-付费-："><a href="#UFT-付费-：" class="headerlink" title="UFT(付费)："></a><a href="https://software.microfocus.com/fr-ca/software/uft" target="_blank" rel="noopener">UFT</a>(付费)：</h4><p>UFT（Unified Functional Testing）是著名的商业功能测试工具。它为跨平台的桌面、web和移动应用程序的API、web服务和GUI测试提供了全面的功能集。该工具具有先进的基于图像的对象识别功能、可重用的测试组件和自动化文档。</p><p>UFT使用Visual Basic脚本编写测试过程和对象控制。UFT与业务流程测试和质量中心集成，该工具通过与诸如Jenkins之类的CI工具集成来支持CI。</p><h4 id="Sahi-Pro-付费-："><a href="#Sahi-Pro-付费-：" class="headerlink" title="Sahi Pro(付费)："></a><a href="http://sahipro.com/" target="_blank" rel="noopener">Sahi Pro</a>(付费)：</h4><p>(付费)：<br>Sahi Pro帮助自动化web应用程序的功能测试Sahi Pro默认支持web应用程序和REST API自动化。Sahi Pro非常适合对具有大量AJAX和动态内容的复杂web 2.0应用程序进行跨浏览器/多浏览器测试。Sahi Pro运行在任何支持javascript的现代浏览器上它支持您测试web浏览器、桌面和移动应用程序它是一个面向测试人员的自动化回归测试工具。</p><pre><code>特点：1.  内置的Excel框架，让您的业务分析师和非技术专业人士有助于测试。2.  简单而强大的api3.  对象获取器和记录器4.  自动记录和报告5.  并行和分布式回放6.  持续集成7.  在任何操作系统上测试任何浏览器8.  测试任何Windows桌面应用程序9.  测试任何iOS和Android、本机和混合应用程序</code></pre><h4 id="TestComplete-付费-："><a href="#TestComplete-付费-：" class="headerlink" title="TestComplete(付费)："></a><a href="https://smartbear.com/" target="_blank" rel="noopener">TestComplete</a>(付费)：</h4><p>由SmartBear完成的TestComplete是一个强大的商业测试工具，用于web、移动和桌面测试。它支持各种脚本语言，如JavaScript、VBScript、Python和C++脚本。与Katalon Studio一样，测试人员可以使用TestComplete执行关键字驱动和数据驱动的测试，该工具还提供了一个易于使用的录制和回放功能。</p><p>与UTF一样，TestComplete的GUI对象识别功能可以自动检测和更新UI对象，这有助于减少在AUT更改时维护测试脚本的工作量在CI过程中，它还与Jenkins集成。</p><h4 id="Watir（开源）："><a href="#Watir（开源）：" class="headerlink" title="Watir（开源）："></a><a href="http://watir.com/" target="_blank" rel="noopener">Watir</a>（开源）：</h4><p>Watir是一个基于Ruby库的web自动化测试的开源测试工具。Watir支持跨浏览器测试，包括Firefox、Opera、headless browser和IE。它还支持数据驱动测试，并与诸如RSpec、Cucumber和Test/Unit等BBD工具集成。</p><h4 id="IBM-Rational-Functional-Tester-付费-："><a href="#IBM-Rational-Functional-Tester-付费-：" class="headerlink" title="IBM Rational Functional Tester(付费)："></a><a href="https://www.ibm.com/" target="_blank" rel="noopener">IBM Rational Functional Tester</a>(付费)：</h4><p>IBM RFT是一个用于功能和回归测试的数据驱动测试平台。它支持很多的应用程序，如.Net、Java、SAP、Flex和Ajax。RFT使用Visual Basic.Net和Java作为脚本语言。用户对AUT的操作，通过应用程序屏幕截图以脚本格式记录。</p><p>RFT的另一个有趣的特性是它与IBM Jazz应用程序生命周期管理系统（如ibmrationalteamconcert和Rational Quality Manager）的集成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里我们聊了什么是回归测试，回归测试切入的时间点，以及如何才能高效的去执行我们的回归测试以及一些基本的回归测试的工具。希望可以对大家有所帮助，如果大家对于回归测试有什么好的测试想法和测试工具的推荐，请在留言区回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在测试阶段，在每次迭代的时候，我们需要回归检验下前期完成的功能，来保证新的提交没有导致系统功能的衰退。所以回归测试在整个测试的生命周期中起到
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十二）功能测试的介绍和工具选择</title>
    <link href="https://xingyichuan.github.io/2019/10/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%BA%8C)%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/"/>
    <id>https://xingyichuan.github.io/2019/10/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%BA%8C)%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/</id>
    <published>2019-10-31T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:48.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一次分享中，我们介绍了《<a href="https://segmentfault.com/a/1190000020909527" target="_blank" rel="noopener">软件测试笔记（十三）单元测试的介绍和工具选择</a>》。今天我会介绍作为测试的重点之一的功能测试，因为关于功能测试是和软件的具体功能紧密结合的，所以这里会基本介绍下功能测试和市面上常用的功能测试的工具。</p><h2 id="功能测试的定义"><a href="#功能测试的定义" class="headerlink" title="功能测试的定义"></a>功能测试的定义</h2><p>功能测试简单来说就是验证软件的每一个功能是否按照需求文档中的规定运行，通过输入适当的输入来测试功能，以验证实际输出是够与预期的输出匹配。它属于黑盒测试的范围，测试人员可以不需要关心功能内部如何实现。</p><h2 id="功能测试的种类"><a href="#功能测试的种类" class="headerlink" title="功能测试的种类"></a>功能测试的种类</h2><p>下面列举了一些重要的功能测试的类型：</p><p><img src="/2019/10/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%BA%8C)%20%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/bVbzYLc" alt="image.png"></p><ul><li>单元测试：为了检查源代码的单个单元或模块是否正常工作，同时保证对应功能模块按照需求文档实现。它是由开发人员在开发人员的环境中完成的。</li><li>集成测试：集成测试是测试两个软件单元之间接口的过程。集成测试通过多种方法完成，如大爆炸方法、自顶向下方法、自下而上方法和混合集成方法来保证用户数据流，逻辑流按照需求文档中定义的实现。</li><li>系统测试：测试完全集成的软件以评估系统是否符合其指定的需求称为系统测试（也称为端到端测试）。目标是已完成的软件和功能，以确保软件和功能是否按预期工作。</li><li>回归测试：在修复完缺陷后，对已经测试的软件和功能进行重复测。用来发现由于正在测试的软件和功，因为其他相关或不相关的组件的更改而引入或发现的任何缺陷。</li><li>用户验收测试：也称之发布前测试，由最终用户和测试人员一起完成的，以验证应用程序的功能。验收测试为确定应用程序是否按要求开发，而进行的测试，同时它需要得到客户的反馈接受或拒绝。申请验收测试的类型有Alpha、Beta和Gamma测试。</li></ul><h2 id="功能测试的测试技术"><a href="#功能测试的测试技术" class="headerlink" title="功能测试的测试技术"></a>功能测试的测试技术</h2><p>功能测试的主要目的就是要保证软件的功能复合测试需求。所以它可以按照以下的方法执行：</p><ul><li>基于需求的测试：它包含所有的功能规范，这些规范构成了编写的所有测试用例的基础。</li><li>基于业务场景的测试：它包含有关如何从业务流程的角度感知系统的信息。</li></ul><h2 id="功能测试的主流工具"><a href="#功能测试的主流工具" class="headerlink" title="功能测试的主流工具"></a>功能测试的主流工具</h2><p>这里介绍的功能测试工具，有可能帮助组织更好地定位自己，以跟上软件测试的趋势，该列表包括开源和商业功能测试解决方案。</p><h4 id="Selenium-（开源）"><a href="#Selenium-（开源）" class="headerlink" title="Selenium （开源）:"></a><a href="http://www.seleniumhq.org/" target="_blank" rel="noopener">Selenium</a> （开源）:</h4><p>Selenium可能是Web应用程序最流行的开源测试自动化框架。Selenium起源于2000年代，经过十多年的发展，已经成为Web自动化测试人员的首选自动化框架。Selenium已经成为Katalon Studio、Watir、dragor和Robot framework等其他开源测试自动化工具的核心框架。</p><p>Selenium支持多种系统环境（Windows、Mac、Linux）和浏览器（Chrome、Firefox、IE和Headless浏览器）它的脚本可以用各种编程语言编写，如Java、Groovy、Python、C#、PHP、Ruby和Perl。虽然对测试人员具有灵活性，他们可以编写复杂的测试脚本，以满足不同级别的复杂性，但它需要提高编程技巧和努力来构建自动化框架和库以满足特定测试需求。</p><h4 id="UFT-付费-："><a href="#UFT-付费-：" class="headerlink" title="UFT (付费)："></a><a href="https://software.microfocus.com/fr-ca/software/uft" target="_blank" rel="noopener">UFT</a> (付费)：</h4><p>UFT（Unified Functional Testing）是著名的商业功能测试工具。它为跨平台的桌面、web和移动应用程序的API、web服务和GUI测试提供了全面的功能集。该工具具有先进的基于图像的对象识别功能、可重用的测试组件和自动化文档。</p><p>UFT使用Visual Basic脚本编写测试过程和对象控制。UFT与业务流程测试和质量中心集成，该工具通过与诸如Jenkins之类的CI工具集成来支持CI。</p><h4 id="Watir（开源）："><a href="#Watir（开源）：" class="headerlink" title="Watir（开源）："></a><a href="http://watir.com/" target="_blank" rel="noopener">Watir</a>（开源）：</h4><p>Watir是一个基于Ruby库的web自动化测试的开源测试工具。Watir支持跨浏览器测试，包括Firefox、Opera、headless browser和IE。它还支持数据驱动测试，并与诸如RSpec、Cucumber和Test/Unit等BBD工具集成。</p><h4 id="IBM-Rational-Functional-Tester-付费-："><a href="#IBM-Rational-Functional-Tester-付费-：" class="headerlink" title="IBM Rational Functional Tester (付费)："></a><a href="https://www.ibm.com/" target="_blank" rel="noopener">IBM Rational Functional Tester</a> (付费)：</h4><p>IBM RFT是一个用于功能和回归测试的数据驱动测试平台。它支持很多的应用程序，如.Net、Java、SAP、Flex和Ajax。RFT使用Visual Basic.Net和Java作为脚本语言。用户对AUT的操作，通过应用程序屏幕截图以脚本格式记录。</p><p>RFT的另一个有趣的特性是它与IBM Jazz应用程序生命周期管理系统（如ibmrationalteamconcert和Rational Quality Manager）的集成。</p><h4 id="TestComplete-付费-："><a href="#TestComplete-付费-：" class="headerlink" title="TestComplete (付费)："></a><a href="https://smartbear.com/" target="_blank" rel="noopener">TestComplete</a> (付费)：</h4><p>由SmartBear完成的TestComplete是一个强大的商业测试工具，用于web、移动和桌面测试。它支持各种脚本语言，如JavaScript、VBScript、Python和C++脚本。与Katalon Studio一样，测试人员可以使用TestComplete执行关键字驱动和数据驱动的测试，该工具还提供了一个易于使用的录制和回放功能。</p><p>与UTF一样，TestComplete的GUI对象识别功能可以自动检测和更新UI对象，这有助于减少在AUT更改时维护测试脚本的工作量在CI过程中，它还与Jenkins集成。</p><h4 id="Tricentis-Tosca-付费-："><a href="#Tricentis-Tosca-付费-：" class="headerlink" title="Tricentis Tosca(付费)："></a><a href="https://www.tricentis.com/" target="_blank" rel="noopener">Tricentis Tosca</a>(付费)：</h4><p>Tricentis Tosca是一个基于模型的测试自动化工具，它为连续测试提供了相当广泛的功能集，包括支持敏捷和DevOps方法的Dashboard、分析和集成。<br>Tricentis Tosca帮助用户优化测试脚本的可重用性。与许多其他测试自动化工具一样，它支持多种技术和应用程序，如web、移动和APITricentis Tosca还具有集成管理、风险分析和分布式执行的功能。</p><h4 id="Ranorex-付费-："><a href="#Ranorex-付费-：" class="headerlink" title="Ranorex(付费)："></a><a href="https://www.ranorex.com/" target="_blank" rel="noopener">Ranorex</a>(付费)：</h4><p>Ranorex Studio是一个集桌面、移动和web于一体的自动化测试工具，受到全球4000多家公司的信赖该应用程序提供了无代码测试自动化，使初学者能够直接测试，以及一个完整的IDE。</p><p>特点：</p><ol><li>可靠的对象标识，即使对于具有动态id的web元素也是如此。</li><li>可共享对象存储库。</li><li>使用可重用代码模块减少测试维护。</li><li>跨平台和跨浏览器测试。</li><li>使用内置的Selenium WebDriver在Selenium Grid上并行测试或分发。</li><li>可定制，易于阅读的测试报告。</li><li>启用视频报告以查看在不重新运行测试的情况下导致测试失败的原因。</li><li>与完整的测试工具链集成：Azure DevOps、Jira、Jenkins、TestRail、Git等等。</li></ol><h4 id="Sahi-Pro-付费-："><a href="#Sahi-Pro-付费-：" class="headerlink" title="Sahi Pro(付费)："></a><a href="http://sahipro.com/" target="_blank" rel="noopener">Sahi Pro</a>(付费)：</h4><p>(付费)：<br>Sahi Pro帮助自动化web应用程序的功能测试Sahi Pro默认支持web应用程序和REST API自动化。Sahi Pro非常适合对具有大量AJAX和动态内容的复杂web 2.0应用程序进行跨浏览器/多浏览器测试。Sahi Pro运行在任何支持javascript的现代浏览器上它支持您测试web浏览器、桌面和移动应用程序它是一个面向测试人员的自动化回归测试工具。</p><p>特点：</p><ol><li>内置的Excel框架，让您的业务分析师和非技术专业人士有助于测试。</li><li>简单而强大的api</li><li>对象获取器和记录器</li><li>自动记录和报告</li><li>并行和分布式回放</li><li>持续集成</li><li>在任何操作系统上测试任何浏览器</li><li>测试任何Windows桌面应用程序</li><li>测试任何iOS和Android、本机和混合应用程序</li></ol><h4 id="QA-Wizard-付费-："><a href="#QA-Wizard-付费-：" class="headerlink" title="QA Wizard (付费)："></a><a href="https://www.perforce.com/downloads/qa-wizard-pro" target="_blank" rel="noopener">QA Wizard</a> (付费)：</h4><p>QA Wizard Pro自动化了web、Windows和Java应用程序的功能和回归测试，以及web应用程序的负载测试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里介绍了功能测试的定义，关注点，测试技术以及主流的测试工具。当然，这里无法列举出所有的功能测试的工具，如果大家有好的推荐或者是对于功能测试的观点，请留言区留下您的宝贵意见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上一次分享中，我们介绍了《&lt;a href=&quot;https://segmentfault.com/a/1190000020909527&quot; ta
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十一）如何做到有效的集成测试？</title>
    <link href="https://xingyichuan.github.io/2019/10/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%80)%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    <id>https://xingyichuan.github.io/2019/10/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%80)%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/</id>
    <published>2019-10-30T02:00:00.000Z</published>
    <updated>2019-12-04T15:22:15.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件产品的构成都是非常复杂的，这也就意味着它将含有多个模块，这些模块通过接口进行交互。针对于这些集成模块的测试，我们称之为集成测试。也可以认为它是由单元测试扩展出来的。</p><h2 id="集成测试的定义"><a href="#集成测试的定义" class="headerlink" title="集成测试的定义"></a>集成测试的定义</h2><p>集成测试是测试单元模块之间的连接或数据传输的过程。它又称为I&amp;T（集成与测试）。</p><p>它分为大爆炸法、自上而下法、自下而上法和三明治或混合集成法（自上而下和自下而上相结合）。这个过程是通过使用名为stub和Drivers的虚拟程序来执行，其不需要实现软件整个模块，而只是模拟与调用模块的数据通信即可。</p><p>它通常是在单元测试之后完成之后执行的。集成测试中涉及的每个模块都应该在集成测试之前进行单元测试。通过在集成测试之前进行单元测试，可以提高执行软件集成测试的信心。</p><p>集成测试也需要编写相应的测试计划，从而减少了测试的混乱，并为有效执行集成测试提供了清晰的路径。</p><h2 id="集成测试的目标"><a href="#集成测试的目标" class="headerlink" title="集成测试的目标"></a>集成测试的目标</h2><ol><li>降低风险</li><li>验证接口的功能和非功能行为是否符合设计和规定</li><li>建立对接口质量的信心</li><li>查找缺陷（可能接口本身或组件或系统内）</li><li>防止集成接口的缺陷在后期测试中发现</li></ol><h2 id="如何写集成测试用例"><a href="#如何写集成测试用例" class="headerlink" title="如何写集成测试用例"></a>如何写集成测试用例</h2><p>假设网页程序中有三个模块，如“登录页”、“收件箱”和“删除邮件”。</p><p>在编写集成测试用例时，我们不关注单个模块的功能，因为在单元测试期间应该覆盖单个模块，在集成测试阶段我们主要关注模块之间的通信。根据上述假设，我们必须关注“登录页面如何链接到收件箱页面”和“收件箱页面如何链接到删除邮件模块”。</p><p><img src="/2019/10/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%80)%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/bVbzOyV" alt="image.png"></p><h2 id="什么是大爆炸式的集成测试"><a href="#什么是大爆炸式的集成测试" class="headerlink" title="什么是大爆炸式的集成测试"></a>什么是大爆炸式的集成测试</h2><p>它是将所有模块合并一次，并在完成单个模块测试后验证功能。在大爆炸式集成测试中，只有在所有模块都准备好之后，才能集成各个模块。然后他们会去检查它是否表现良好。在这种类型的测试中，可能会出现一些缺点，例如，可能是在很后期发现缺陷。很难定位缺陷是来自于某个模块或者是接口，亦或是集成方面的问题。</p><h2 id="什么是自上而下的集成测试"><a href="#什么是自上而下的集成测试" class="headerlink" title="什么是自上而下的集成测试"></a>什么是自上而下的集成测试</h2><p><img src="/2019/10/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%80)%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/bVbzOA7" alt="image.png"></p><p>在自上向下的集成测试中，测试是自上而下进行的。首先测试高级模块，然后测试低级模块，最后将低级模块集成到高级模块，以确保系统工作正常。</p><p>在这种类型的测试中，如果模块还没有准备好进行集成测试，那么桩程序（stub）将用作临时模块。</p><h2 id="什么是自下而上的集成测试"><a href="#什么是自下而上的集成测试" class="headerlink" title="什么是自下而上的集成测试"></a>什么是自下而上的集成测试</h2><p><img src="/2019/10/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%80)%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/bVbzOBo" alt="image.png"></p><p>在自下而上的集成测试中，测试是自下而上进行的。首先测试底层模块，然后测试高层模块，最后将高层模块集成到低层，以确保系统按预期工作驱动程序用作集成测试的临时模块。</p><h2 id="桩和驱动程序有什么区别"><a href="#桩和驱动程序有什么区别" class="headerlink" title="桩和驱动程序有什么区别"></a>桩和驱动程序有什么区别</h2><p>桩和驱动程序用于组件级的测试</p><p><img src="/2019/10/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81%E4%B8%80)%20%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/bVbzOCE" alt="image.png"></p><p>假设我们在一个应用程序中有两个模块，即“模块1”和“模块2”。开发人员只开发了应用程序的“模块1”。在他们完成“模块2”的开发之前，我们（测试人员）收到了测试“模块1”的要求。我们可以测试“模块1”，如果其与“模块2”没有依赖关系。假设“模块1”依赖于“模块2”。那我们该怎么办？在这种情况下如果想要测试“模块1”，需要开发人员创建一个桩（stub）模块来替换“模块2”。如果“模块2”依赖于“模块1”，但“模块1”尚未就绪，则采用相同的方法在本例中，我们使用驱动（driver）替换“模块1”。</p><p>像我们之前提过的登录并且登录邮箱页面的案例。<br>您必须测试登录页面（假设，邮箱页面正在开发中）。登录页面将在登录后调用邮箱页面，但邮箱页面尚未就绪。为了克服这种情况，开发人员编写了一个虚拟程序作为邮箱页面。这个就是桩（stub）程序。</p><p>桩（stub）被称为“程序”。如果“调用的程序”不完整，则将其替换为桩。（这是自上而下的方法）。</p><p>再来说说驱动程序，登录页面已经准备好了，但不是邮箱页面。这次假设邮箱页面已经准备好测试，但是登录页面还没有准备好。为了克服这种情况，开发人员编写了一个类似于登录页面的虚拟程序。这个虚拟程序就是驱动程序，驱动程序也就是“调用程序”。如果“调用程序”不完整，则将其替换为驱动程序。（这种情况在自下而上的方法中发生）。</p><table><thead><tr><th>桩</th><th>驱动</th></tr></thead><tbody><tr><td>自顶向下集成测试中使用桩</td><td>自下而上集成测试中使用驱动程序</td></tr><tr><td>在开发子程序时使用桩</td><td>开发过程中使用驱动程序</td></tr><tr><td>首先测试最上层的模块</td><td>最底层模块最先测试</td></tr><tr><td>它用来模拟未集成的底层模块的行为</td><td>它用来模拟未集成的上层模块的行为</td></tr><tr><td>桩是被调用程序</td><td>驱动是调用程序</td></tr></tbody></table><h2 id="什么是混合集成测试"><a href="#什么是混合集成测试" class="headerlink" title="什么是混合集成测试"></a>什么是混合集成测试</h2><p>混合集成测试也称为三明治集成测试。它是自顶向下和自下而上集成测试的结合。</p><h2 id="集成测试的工具"><a href="#集成测试的工具" class="headerlink" title="集成测试的工具"></a>集成测试的工具</h2><p>一些集成测试工具如下：</p><ol><li><a href="http://citrusframework.org/" target="_blank" rel="noopener">Citrus Integration Testing</a></li><li><a href="https://www.vectorcast.com/software-testing-products/c-unit-testing" target="_blank" rel="noopener">VectorCAST/C++</a></li><li><a href="http://docs.fitnesse.org/FrontPage" target="_blank" rel="noopener">FitNesse</a></li><li><a href="http://www.validata-software.com/" target="_blank" rel="noopener">Validata</a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>集成测试是测试环节中很重要的一个部分，尤其是在今天软件产品的架构都在向微服务的架构转变，那么集成各个服务间的测试就显得尤为重要。希望对大家有所帮助，如果有疑问或者想法，也请大家留言区回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;软件产品的构成都是非常复杂的，这也就意味着它将含有多个模块，这些模块通过接口进行交互。针对于这些集成模块的测试，我们称之为集成测试。也可以认
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（十）单元测试的介绍和工具选择</title>
    <link href="https://xingyichuan.github.io/2019/10/29/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81)%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/"/>
    <id>https://xingyichuan.github.io/2019/10/29/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81)%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/</id>
    <published>2019-10-29T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:41.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单元测试通常是作为软件测试中基础的测试类型，用于测试单独的模块是否可以正常工作。它于功能测试不同，它更加关注的是代码内部的逻辑，而非是用户的需求。</p><h2 id="单元测试定义"><a href="#单元测试定义" class="headerlink" title="单元测试定义"></a>单元测试定义</h2><p>前面粗略了介绍了单元测试的定义，详细的解释是：单元测试也称为模块测试或组件测试。在软件开发过程中，检查软件的单个单元或模块是否正常工作，它是由开发人员在开发人员的环境中完成的。</p><p><img src="/2019/10/29/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%8D%81)%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9/bVbzTmq" alt="image.png"></p><p>软件测试通常划分为四个层次，每个层次都会去验证软件产品的功能，质量和性能指标。它们是：单元测试，集成测试，系统测试和验收测试。</p><h2 id="单元测试的目标"><a href="#单元测试的目标" class="headerlink" title="单元测试的目标"></a>单元测试的目标</h2><ul><li>隔离代码的每个部分。</li><li>确保单个模块功能正确。</li><li>在开发周期的早期，发现代码缺陷。</li><li>早期介入，以节省测试成本。</li><li>允许开发人员在以后重构或升级代码。</li></ul><h2 id="单元测试的优势"><a href="#单元测试的优势" class="headerlink" title="单元测试的优势"></a>单元测试的优势</h2><ul><li>它在产品开发周期的早期发现问题。因此它降低了测试成本，早发现一个缺陷的成本要比晚发现它的成本低得多。</li><li>在改变现有功能（回归测试）时，它同时可以保证减少缺陷。</li><li>它简化了调试过程（测试驱动开发就是基于测试用例来完成功能开发）。调试是在程序中发现并解决妨碍软件正确运行的缺陷的过程。当实现单元测试时，发现测试失败时，只需要调试代码中所做的更改，就可以快速定位到错误。</li><li>由于更好的编码标准和实践，它给组织提供了更好的代码文档。</li></ul><h2 id="单元测试的内容"><a href="#单元测试的内容" class="headerlink" title="单元测试的内容"></a>单元测试的内容</h2><h4 id="单元测试的方法"><a href="#单元测试的方法" class="headerlink" title="单元测试的方法"></a>单元测试的方法</h4><p>通常单元测试是使用白盒测试的方法</p><h4 id="单元测试的类型"><a href="#单元测试的类型" class="headerlink" title="单元测试的类型"></a>单元测试的类型</h4><p>单元测试可以是手动测试或者是自动化测试</p><h4 id="什么时候执行单元测试"><a href="#什么时候执行单元测试" class="headerlink" title="什么时候执行单元测试"></a>什么时候执行单元测试</h4><p>它作为测试层次的第一层，通常是在集成测试之前完成。</p><h4 id="单元测试有谁执行"><a href="#单元测试有谁执行" class="headerlink" title="单元测试有谁执行"></a>单元测试有谁执行</h4><p>它需要由对于代码内部逻辑熟悉的人执行，通常是开发或者是白盒测试人员。</p><h4 id="单元测试有哪些具体的任务"><a href="#单元测试有哪些具体的任务" class="headerlink" title="单元测试有哪些具体的任务"></a>单元测试有哪些具体的任务</h4><p>首先需要准备单元测试计划：</p><ul><li>准备测试计划</li><li>回顾测试计划</li><li>修订测试计划</li><li>定义单元测试计划的基准数据</li></ul><p>其次是要准备测试用例和脚本：</p><ul><li>准备测试环境和测试用例和脚本</li><li>回顾测试用例和脚本</li><li>修订测试用例和脚本</li><li>定义单元测试用例和脚本的基准数据</li></ul><p>最后是单元测试的执行。</p><h4 id="单元测试的工具"><a href="#单元测试的工具" class="headerlink" title="单元测试的工具"></a>单元测试的工具</h4><p>市面上有很多单元测试的工具，它们可用于协助单元测试。具体的单元测试的工具的选择还是要根据项目的具体情况决定，比如说项目的具体技术栈，是否可以重用已有的单元测试工具等。我们将提供以下几个示例：</p><p><strong><a href="https://junit.org/junit5/" target="_blank" rel="noopener">Junit</a>:</strong><br>Junit的目标是为JVM开发人员开发一个基础测试的测试框架。这包括关注java 8和更高版本，以及支持多种不同风格的测试。</p><p><strong><a href="https://testng.org/doc/" target="_blank" rel="noopener">TestNG</a>:</strong><br>TestNG是一个受JUnit和NUnit启发的测试框架，但是它引入了一些新的功能，这些功能使它更加强大和易于使用，例如：</p><ul><li>注释。</li><li>使用各种可用的策略在任意大的线程池中运行测试（所有方法都在自己的线程中，每个测试类一个线程，等等）。</li><li>测试您的代码是否是多线程安全的。</li><li>灵活的测试配置。</li><li>支持数据驱动测试（使用@dataprovider）。</li><li>参数支持。</li><li>强大的执行模型（不再是TestSuite）。</li><li>由各种工具和插件（eclipse、idea、maven等）支持。</li><li>嵌入BeanShell以获得更大的灵活性。</li><li>运行时和日志记录的默认JDK函数（无依赖项）。</li><li>应用服务器测试的依赖方法。.</li></ul><p><strong><a href="https://nunit.org/" target="_blank" rel="noopener">NUnit</a>:</strong><br>它是.net语言的单元测试框架。最初是从JUnit移植而来的，目前的产品版本3已经被完全重写了，它有许多新特性，并且支持各种各样的.NET平台。</p><p><strong><a href="https://xunit.net/" target="_blank" rel="noopener">xUnit.net</a>:</strong><br>xUnit.net是一个免费的、开源的、面向社区的.net框架单元测试工具xunit.net是由nunit v2的原始发明者编写的，它是用于c、f、vb.net和其他.net语言单元测试的最新技术。xunit.net与resharper、coderash、testdriven.net和xamarin一起工作。它是.NET基金会的一部分，根据他们的行为准则运作。它是根据Apache 2（OSI批准的许可证）授权的。</p><p>**<a href="http://jmockit.github.io/" target="_blank" rel="noopener">JMockit</a>: **<br>JMockit是开源的单元测试工具jmockit是一个用于开发人员测试的java工具包，包括模拟api和代码覆盖工具。</p><p><strong><a href="http://emma.sourceforge.net/" target="_blank" rel="noopener">EMMA</a>：</strong><br>EMMA是一个用于测量和报告java代码覆盖率的开源工具包。EMMA支持大规模的企业软件开发，同时保持单个开发人员的快速工作和迭代团队中的每个开发人员现在都可以免费获得代码覆盖率，最主要的是可以很快的获得覆盖率！</p><p><strong><a href="https://phpunit.de/" target="_blank" rel="noopener">PHPUnit</a>：</strong><br>PHPUnit是一个面向程序员的php测试框架。它是单元测试框架的xunit架构的一个实例。</p><p><strong><a href="https://www.qa-systems.com/tools/cantata/" target="_blank" rel="noopener">Cantata</a>:</strong><br>Cantata是一个单元和集成测试工具，使开发人员能够在本地和嵌入式目标平台上验证标准兼容或业务关键代码。<br>Cantata通过自动化，帮助加速符合标准的动态测试要求：</p><ul><li>测试框架生成</li><li>测试用例生成</li><li>测试执行</li><li>结果诊断和报告生成</li></ul><p><strong><a href="https://smartbear.com/product/testcomplete/overview/" target="_blank" rel="noopener">TestComplete</a>:</strong><br>TestComplete是一个适用于多种应用类型和技术的自动化测试环境，包括（但不限于）Windows、.NET、WPF、Visual C++、Visual Basic、Delphi、C++Builder、Java和Web应用程序和服务。</p><p><strong><a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>:</strong><br>Mocha是一个功能丰富的javascript测试框架，运行在node.js和浏览器中，使异步测试变得简单有趣。MOCA测试连续运行，允许灵活且准确的报告，同时将异常异常映射到正确的测试用例。托管在github上。</p><p><strong><a href="https://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>:</strong><br>Jasmine是一个用于测试JavaScript代码的行为驱动开发框架它不依赖于任何其他JavaScript框架它不需要dom。而且它有一个干净、明显的语法，所以您可以轻松地编写测试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单元测试作为测试的第一层次，被很早引入项目。所以在项目开始前，我们同时需要对单元测试的技术选型和测试案例的计划进行准备。这样才可以在项目研发阶段，同时实现单元测试，以保证功能模块的功能。如果大伙有关于单元测试的一些看法，也请留言区回复和分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;单元测试通常是作为软件测试中基础的测试类型，用于测试单独的模块是否可以正常工作。它于功能测试不同，它更加关注的是代码内部的逻辑，而非是用户的
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（九）怎么样写才是一个好的缺陷报告？</title>
    <link href="https://xingyichuan.github.io/2019/10/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B9%9D)%20%E4%BC%98%E7%A7%80%E7%9A%84%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A/"/>
    <id>https://xingyichuan.github.io/2019/10/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B9%9D)%20%E4%BC%98%E7%A7%80%E7%9A%84%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A/</id>
    <published>2019-10-28T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:25.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个开发人员，你是否会因为测试人员提交的缺陷报告缺少重要的内容而无法重现缺陷。作为一个测试人员，你是否会收到开发人员拒绝的缺陷报告，而显示的内容是“它是不可复制的”。这些都是在项目开发中经常会遇到的情况，通常的原因是因为缺陷报告的说明不够完整，没有足够多的有用信息。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>本人曾经在测试中遇到过这样的一个问题，当我在使用Chrome进行测试的时候，发现在某一个特殊版本，产品所使用的Threejs的库无法正常使用。创建缺陷报告的时候，我列举了所有重现的步骤，但是没有列出具体使用的浏览器的类型和版本。</p><p>当开发人员试图重现这个缺陷的时候，他使用的是Firefox。而对应的功能在Firefox中可以正常使用，开发人员直接拒绝修复此缺陷，当我得到打回来的缺陷报告，我又重复了一下缺陷发现还是可以重现，结果又指给了开发人员。。。这样反复操作后，最后通过当面演示才把缺陷给开发人员展示清楚。这样的反反复复的过程，大量的浪费了开发和测试人员的时间和精力。</p><p>其根本原因是没有在缺陷报告中提到浏览器的类型和版本，如果测试人员在测试报告中忘记提到重现错误的关键信息，那将面临同样的后果。</p><p>有句老话：“你永远不会有第二次机会给人留下第一印象。”</p><p>编写好的缺陷报告是每个测试人员都应该具备的技能。您必须向开发团队提供所有必要的详细信息，以解决您的问题。</p><p>你想在不被拒绝的情况下修复提交的缺陷吗？所以你必须用一个好的缺陷报告来报告它。</p><h2 id="如何写出一个好的缺陷报告？"><a href="#如何写出一个好的缺陷报告？" class="headerlink" title="如何写出一个好的缺陷报告？"></a>如何写出一个好的缺陷报告？</h2><p>首先，先说下好的缺陷报告的构成要素：缺陷ID、报告者名称、缺陷报告日期、检测者、检测方式、项目名称、发布/构建版本、缺陷/增强、环境、优先级、严重性、状态、描述、复制步骤、URL、预期结果、实际结果、必要的截图和录像。</p><p>之前在《<a href="https://segmentfault.com/a/1190000020852793" target="_blank" rel="noopener">缺陷报告应该涵盖哪些内容</a>》提到了这里列举的每一个要素的详细解释。</p><p>在正式提交缺陷报告前，一定要重要的事情重现三遍的原则，首先保证缺陷可以被重复三遍。</p><p>当确定缺陷存在后，那么确定是否同一个缺陷是否其他的测试人员也已经提交了。通常可以使用一些与缺陷相关的关键字，并在缺陷跟踪工具中搜索如果您没有发现与您发现的错误相同的问题，如果还不确信可以找相关的资深测试咨询，接着您可以开始编写错误报告。</p><p>等等，也许我们可以做的更多！</p><p>我们是否可以确定相关模块中是否存在相同的问题？如果您发现相关模块中存在相同的问题，则可以在相同的错误报告中解决这些问题。这样就可以节省编写多个缺陷报告的时间，提高测试效率。</p><p>接下来我们可以通过在上面提到的构成要素开始编写bug报告，并编写详细的步骤来重现。</p><p>在报告一个bug之前，做一个检查表并确保你已经通过了所有的要点。</p><ol><li>缺陷重复2-3次。</li><li>使用一些与缺陷相关的关键字，并在缺陷跟踪工具中搜索。</li><li>测试类似模块，看看是否有相同的问题。</li><li>立即报告缺陷。</li><li>写下详细的步骤来重现错误。</li><li>写一份好的缺陷总结在写错误报告的过程中注意你的语言，对事不对人，尽量抽取有用的信息。</li><li>建议使用适当的屏幕截图来说明问题。</li><li>在发布你的错误报告之前要校对两到三次。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的缺陷报告可以让阅读的人员快速准确的定位问题，同样也可以提高整个产品研发的效率。如果大家还有其他好的建议关于缺陷报告，也请在留言区回复我，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一个开发人员，你是否会因为测试人员提交的缺陷报告缺少重要的内容而无法重现缺陷。作为一个测试人员，你是否会收到开发人员拒绝的缺陷报告，而显
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（八）缺陷报告应该涵盖哪些内容</title>
    <link href="https://xingyichuan.github.io/2019/10/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%85%AB)%20%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E5%BA%94%E5%86%85%E5%AE%B9/"/>
    <id>https://xingyichuan.github.io/2019/10/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%85%AB)%20%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E5%BA%94%E5%86%85%E5%AE%B9/</id>
    <published>2019-10-27T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:12.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>测试的工作的很重要的一个部分就是报告缺陷，并伴随着测试的进行不断地更新。因为缺陷报告是给开发，项目负责人，等相关人员看的，所以需要把尽可能的信息涵盖在缺陷报告中去，比如环境的详细信息，测试的重现步骤，等，帮助相关人员可以快速的重现描述的缺陷。</p><h2 id="缺陷报告模板"><a href="#缺陷报告模板" class="headerlink" title="缺陷报告模板"></a>缺陷报告模板</h2><p>下面会给大家介绍一下，常用的缺陷报告的模板，希望可以帮助大家写出一个好的缺陷报告。</p><h4 id="缺陷ID："><a href="#缺陷ID：" class="headerlink" title="缺陷ID："></a>缺陷ID：</h4><p>按照项目约定的命名添加缺陷ID。缺陷管理工具会自动生成缺陷标识。通常会包括项目名称的简写，例如INVGEN-0001。</p><h4 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h4><p>标题应该简短。它应该包含与实际问题相关的具体术语。写标题时要具体，尽量描述清楚需要阐述的缺陷。<br>例如：假设您在上载具有特定文件格式（即jpeg文件）的个人资料图片时，在注册页中发现了一个错误。那标题可以写“上载JPEG文件时系统崩溃”。不太好的例子是“系统崩溃”。</p><h4 id="缺陷提交者："><a href="#缺陷提交者：" class="headerlink" title="缺陷提交者："></a>缺陷提交者：</h4><p>发现缺陷的人的姓名（通常是测试人员的姓名，但有时可能是开发人员、业务分析师、主题专家（SME）、客户）。这样便于后期确认缺陷时，方便找到缺陷的提交者。</p><h4 id="缺陷报告日期："><a href="#缺陷报告日期：" class="headerlink" title="缺陷报告日期："></a>缺陷报告日期：</h4><p>注明发现缺陷的日期。</p><h4 id="发现者类型："><a href="#发现者类型：" class="headerlink" title="发现者类型："></a>发现者类型：</h4><p>指定发现缺陷者的所属角色。例如：质量保证、开发人员、业务分析师、中小企业、客户。通常对于客户的问题，项目会比较重视。</p><h4 id="项目名称："><a href="#项目名称：" class="headerlink" title="项目名称："></a>项目名称：</h4><p>有时，测试人员可能同时处理多个项目。因此，正确选择项目名称，会有助于快速定位出问题的项目。（如果是产品，请指定产品名称）。</p><h4 id="发布版本："><a href="#发布版本：" class="headerlink" title="发布版本："></a>发布版本：</h4><p>发布/生成版本：发生此问题的发布版本。清楚地提到构建版本的详细信息。这样有助于开发迅速切换到对饮的版本进行重现和调试。</p><h4 id="缺陷类型："><a href="#缺陷类型：" class="headerlink" title="缺陷类型："></a>缺陷类型：</h4><p>缺陷/增强：如果系统未按预期运行，则需要将其指定为缺陷。如果只是对新功能的请求，则必须将其指定为增强功能。</p><h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><p>必须说明操作系统的详细信息、浏览器的详细信息以及与遇到错误的测试环境相关的任何其他信息。<br>例子:Window 10的Microsoft Edge 44.18362.387.0</p><h4 id="优先等级："><a href="#优先等级：" class="headerlink" title="优先等级："></a>优先等级：</h4><p>优先等级定义修复错误的时间。通常，bug的优先级由管理者设置。根据优先级，开发人员可以了解修复的时间，并设置错误的解决顺序。通常分为高，中等，低。</p><h4 id="严重等级："><a href="#严重等级：" class="headerlink" title="严重等级："></a>严重等级：</h4><p>严重等级是指错误对客户业务的影响。通常，错误的严重性由管理者设置。有时，测试人员会选择bug的严重性，但在大多数情况下，它将由经理/主管选择。<br>通常分为：阻滞，非常重要，重要的，一般的，不严重的。</p><h4 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h4><p>指定错误的状态。如果你刚刚发现了一个bug并准备发布它，那么状态将是“new”。在bug修复过程中，bug的状态将改变。<br>例如，新的/分配的/打开的/已修复的/测试的/验证的/关闭的/重新打开的/重现的/延迟的/拒绝的/无法修复的/不可重现的/需要更多信息，等。</p><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>在“描述”部分中，必须简要说明在面对错误之前所做的工作。</p><h4 id="重现步骤："><a href="#重现步骤：" class="headerlink" title="重现步骤："></a>重现步骤：</h4><p>描述如何一步一步地重现缺陷。方便重现的步骤为开发人员提供了在不出现任何干扰项的情况下解决缺陷。这些步骤应该能够很好地描述缺陷，并允许开发人员理解缺陷并对其进行操作，而无需与报告缺陷的人进行讨论。可以从“打开应用程序”开始，如果有“先决条件”，则包括“先决条件”，并一直写到“导致错误”的步骤。</p><p>好的案例：</p><ol><li>打开网址“你的网址”</li><li>点击“注册页面”</li><li>在个人资料照片栏上传“jpeg”文件</li></ol><p>坏的案例：</p><ol><li>在注册页上载文件。</li></ol><h4 id="预期结果："><a href="#预期结果：" class="headerlink" title="预期结果："></a>预期结果：</h4><p>当您执行导致失败的操作时，应用程序的预期输出是什么。<br>好的案例：消息应显示“成功上载个人资料图片”<br>不好的案例：系统应接受配置文件图片。</p><h4 id="实际结果："><a href="#实际结果：" class="headerlink" title="实际结果："></a>实际结果：</h4><p>当您执行导致失败的操作时，应用程序的预期输出是什么。<br>好的案例：“在注册页面上传jpeg文件（个人资料图片）会导致系统崩溃”。<br>不好的案例：系统不接受配置文件图片。</p><h4 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h4><p>附上当你面对错误时捕捉到的截图或者视频。它帮助开发人员看到您所面临的缺陷。</p><h4 id="缺陷关闭日期："><a href="#缺陷关闭日期：" class="headerlink" title="缺陷关闭日期："></a>缺陷关闭日期：</h4><p>“缺陷关闭日期”是在确保缺陷不可重现缺陷后需要更新的日期。</p><h4 id="缺陷关闭版本："><a href="#缺陷关闭版本：" class="headerlink" title="缺陷关闭版本："></a>缺陷关闭版本：</h4><p>“缺陷关闭版本”是在确保缺陷不可重现缺陷后需要更新的对应的应用程序的版本。</p><h4 id="自动化脚本测试："><a href="#自动化脚本测试：" class="headerlink" title="自动化脚本测试："></a>自动化脚本测试：</h4><p>如果缺陷已经添加了相应的自动化案例，通常需要关联自动化对应的测试用例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的缺陷报告会方便开发或者相关人员重现对应的缺陷，帮助我们快速定位缺陷并且解决缺陷，同时提高整个项目的开发效率。作为一个合格的测试人员，必须将编写测试报告作为一个需要锻炼的技能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;测试的工作的很重要的一个部分就是报告缺陷，并伴随着测试的进行不断地更新。因为缺陷报告是给开发，项目负责人，等相关人员看的，所以需要把尽可能的
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（七）测试用例需要的内容</title>
    <link href="https://xingyichuan.github.io/2019/10/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B8%83)%20%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>https://xingyichuan.github.io/2019/10/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B8%83)%20%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</id>
    <published>2019-10-26T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:32.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>测试用例，通常按照测试用例模板文件，为特定的测试场景开发测试用例，以验证应用程序的功能是否按预期工作，符合客户的需求。测试用例是针对一个测试场景的可执行步骤的集合，包含前置条件、测试数据、预期结果、后置条件和实际结果。</p><p>大多数公司都在使用测试用例管理工具，如HP的QC, Jira等，还有一些公司仍在使用excel表格编写测试用例。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>假设我们需要为一个场景编写测试用例（验证帐户的登录）。</p><p>这里有一个测试用例。</p><p>一。输入有效用户名和有效密码</p><p>二。输入有效用户名和无效密码</p><p><img src="/2019/10/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B8%83)%20%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/bVbzHRl" alt="image.png"></p><h2 id="测试用例构成元素"><a href="#测试用例构成元素" class="headerlink" title="测试用例构成元素"></a>测试用例构成元素</h2><ul><li><p>项目名称：测试用例所属的项目的名称</p></li><li><p>模块或者功能名称：测试用例所属的模块或者功能的名称</p></li><li><p>参考文档：提及参考文档的链接（如果有，如需求文档、测试计划、测试场景等）</p></li><li><p>创建人：创建测试用例的测试人员的姓名</p></li><li><p>创建日期：创建测试用例的时间</p></li><li><p>审查人：创建测试用例的测试人员的姓名</p></li><li><p>审查日期：审查测试用例的时间</p></li><li><p>执行人：执行测试用例的测试人员的姓名</p></li><li><p>执行日期：测试用例执行的时间</p></li><li><p>测试用例ID：每个测试用例都应该用一个唯一的ID来表示。为了更好地理解和区分目的，最好遵循一些命名约定。</p></li><li><p>测试场景：测试场景的ID或标题。</p></li><li><p>测试用例：测试用例的标题</p></li><li><p>前置条件：在执行测试用例之前需要满足的条件。</p></li><li><p>测试步骤：详细说明所有测试步骤，并按顺序说明如何执行。</p></li><li><p>测试数据：可以作为测试用例输入的数据。</p></li><li><p>预期结果：测试用例执行后的预期结果。它可能是任何东西，如主页、相关屏幕、错误消息等，</p></li><li><p>后置条件：测试用例成功执行时需要达到的条件。</p></li><li><p>实际结果：测试用例执行后系统显示的结果。</p></li><li><p>状态：如果实际结果和预期结果相同，则表示已通过。否则就失败了。如果测试失败，它必须经过错误生命周期才能修复。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测试用例的受众群体是执行测试的人员，所以测试用例需要最直观的把需要测试的点列举出来，可以结合测试用例的设计原则，最大最小值，因果法，边际条件等，把测试用例编写完全。同时如果某些测试用例也已经实现了自动化，可以在测试用例模板中标记出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;测试用例，通常按照测试用例模板文件，为特定的测试场景开发测试用例，以验证应用程序的功能是否按预期工作，符合客户的需求。测试用例是针对一个测试
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（四）如何正确的姿势写测试策略文档？</title>
    <link href="https://xingyichuan.github.io/2019/10/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%BA%94)%20%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E6%96%87%E6%A1%A3/"/>
    <id>https://xingyichuan.github.io/2019/10/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%BA%94)%20%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E6%96%87%E6%A1%A3/</id>
    <published>2019-10-25T02:00:00.000Z</published>
    <updated>2019-12-04T15:22:21.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无论是打仗，辩论，讨价还价，都需要有个策略来指导我们的具体操作。那么测试也一样，需要用正确的姿势来打开测试策略。通常它是如何测试产品来实现测试目标，并且根据业务需求规范（BRS）的为基础编写的一个文档。</p><p>通常测试团队会基于测试测试策略来定制详细的测试计划。测试策略对于敏捷开发尤为重要，其原因开发周期短，测试计划粗略。在整个项目开发中，有这样的指导性的测试策略可以降低不可预见的风险。</p><p>准备此文档的人也有责任和义务给整个项目组织分享这个文档，让大家可以更好的了解项目的范围，测试的方法还有一些重要的约定。</p><h2 id="测试策略的组成"><a href="#测试策略的组成" class="headerlink" title="测试策略的组成"></a>测试策略的组成</h2><p>通常会分为下面的几大组成部分：</p><ol><li>测试的范围和基本概述</li><li>测试的方法</li><li>测试工具的选择</li><li>需要遵循的行业标准和业务流程</li><li>测试的交付成果</li><li>测试的指标</li><li>需求矩阵</li><li>风险和评估</li><li>报告工具</li><li>测试总结</li></ol><h4 id="测试范围和基本概述"><a href="#测试范围和基本概述" class="headerlink" title="测试范围和基本概述"></a>测试范围和基本概述</h4><p>这部分涵盖了具体测试活动范围，要测试哪些点和测试点的需求到底是从哪里得到的，当然也包括自动化测试的基本概述。</p><p>比如说：创建一个电子商务的平台。测试电子商务平台的功能，确保可以让交易双方满意。</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>不能讲上次分享中的所有测试方法过全部列举进去，通常需要考虑下面的几个方向。</p><ul><li>测试级别<br>  在软件测试阶段的测试级别，如单元测试、集成测试、系统测试和用户验收测试。测试人员负责集成测试、系统测试和用户验收测试。</li><li>测试类型<br>  具体列出了将在测试在测试期间执行的测试类型，如功能测试，性能测试，压力测试，安全测试等。</li><li>角色和职责<br>  本节描述了项目经理、项目负责人、开发人员，测试人员的角色和职责。</li><li>测试环境的要求<br>  列举测试环境的硬件和软件，以便开始测试活动。</li></ul><h4 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h4><p>这部分列举了测试所需要的测试工具。</p><p>比如：测试管理工具的名称、错误跟踪工具的名称、自动化工具的名称。</p><h4 id="需要遵循的行业标准和业务流程"><a href="#需要遵循的行业标准和业务流程" class="headerlink" title="需要遵循的行业标准和业务流程"></a>需要遵循的行业标准和业务流程</h4><p>这部分将描述相关的行业标准和业务流程，借以满足或超过客户期望的高质量系统。通常，项目经理会决定为实现项目目标所需遵循的测试模型和过程。</p><h4 id="测试的交付成果"><a href="#测试的交付成果" class="headerlink" title="测试的交付成果"></a>测试的交付成果</h4><p>这部分包括列举测试之前、测试期间和测试结束时需要生成的可交付成果。</p><h4 id="测试的指标"><a href="#测试的指标" class="headerlink" title="测试的指标"></a>测试的指标</h4><p>这部分包括定义了项目中用于分析项目状态的度量和各个指标。</p><h4 id="需求矩阵"><a href="#需求矩阵" class="headerlink" title="需求矩阵"></a>需求矩阵</h4><p>这个矩阵确保需求跟踪到验证需求是否得到满足所需的测试。</p><h4 id="风险和评估"><a href="#风险和评估" class="headerlink" title="风险和评估"></a>风险和评估</h4><p>识别和评估将影响测试过程的所有测试风险，并指定降低风险的计划。</p><h4 id="报告工具"><a href="#报告工具" class="headerlink" title="报告工具"></a>报告工具</h4><p>如何使用报告工具跟踪缺陷和问题。</p><h4 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h4><p>需要生成的测试报告的类型以及频率。测试报告将根据项目的重要性每天、每周或每月生成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测试策略文档给出了测试团队将为整个项目做什么，怎么测试给出了的清晰愿景。准备此文档的人必须在相关行业有良好的经验，此文档将驱动整个团队，并且在整个项目生命周期内基本不会更改。测试策略文档应在测试活动开始前分发给整个测试团队。编写一个好的测试策略可以改进整个测试过程，从而产生一个高质量的系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;无论是打仗，辩论，讨价还价，都需要有个策略来指导我们的具体操作。那么测试也一样，需要用正确的姿势来打开测试策略。通常它是如何测试产品来实现测
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（六）软件测试计划</title>
    <link href="https://xingyichuan.github.io/2019/10/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%85%AD)%20%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/"/>
    <id>https://xingyichuan.github.io/2019/10/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%85%AD)%20%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</id>
    <published>2019-10-25T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:28.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件测试计划"><a href="#软件测试计划" class="headerlink" title="软件测试计划"></a>软件测试计划</h2><p>产品的开发需要文档，软件测试同样需要这样的文档。它包含了测试活动的内容，确保客户的需求被高质量的实现和交付。测试文档的定义则是从产品的定义，项目的相关文档，客户的需求文档中派生出来的。</p><p>它通常是测试的经理或者测试负责人来完成，具体内容包括了测试范围，要测试什么，不测试什么，如何实施测试，执行测试，有谁负责某个功能模块，测试需要选择什么样的测试工具，测试框架，配置怎么样的测试环境，测试自动化如何集成到CI/CD中，需要遵循的测试技术准则，会有怎么样的测试风险以及如何去应对这些风险。</p><p>它不是一个静态的文档，通常会随着项目的迭代开发而改变。它指导我们如何去执行测试，这样影响到最终产品的顺利交付。</p><p>同样它也是测试人员需要交付的一个文档，该文档也需要和研发团队，项目负责人一同分享。尽可能让团队成员了解到测试范围，方法，目标以及时间表。</p><h2 id="如何制定有效的测试计划"><a href="#如何制定有效的测试计划" class="headerlink" title="如何制定有效的测试计划"></a>如何制定有效的测试计划</h2><h3 id="谁来准备测试计划"><a href="#谁来准备测试计划" class="headerlink" title="谁来准备测试计划"></a>谁来准备测试计划</h3><p>通常，测试负责人准备测试计划，测试人员参与测试计划文件的编制过程。一旦测试计划准备好了，测试人员就会根据测试计划文档写测试场景和测试用例。</p><h3 id="测试计划的模板"><a href="#测试计划的模板" class="headerlink" title="测试计划的模板"></a>测试计划的模板</h3><p>下面列举的每个方面都是符合标准IEEE 829的。 </p><ol><li>测试计划标识符</li><li>文档列表</li><li>项目介绍</li><li>测试项目列表</li><li>待测试功能</li><li>未测试功能</li><li>实现方法</li><li>合格/不合格标准</li><li>中止标准</li><li>测试可交付成果</li><li>测试任务</li><li>测试环境</li><li>责任</li><li>人员配置和培训需求</li><li>时刻表</li><li>风险和突发情况</li><li>批准</li></ol><h4 id="1-测试计划标识符"><a href="#1-测试计划标识符" class="headerlink" title="1. 测试计划标识符"></a>1. 测试计划标识符</h4><p>测试计划标识符是用于标识测试计划的唯一编号。<br>示例：项目_0001</p><h4 id="2-文档列表"><a href="#2-文档列表" class="headerlink" title="2. 文档列表"></a>2. 文档列表</h4><p>将指定支持当前创建的测试计划的所有文档列表。<br>示例：SRS（系统需求规范）、用例文档、测试策略、项目计划、项目指南等，</p><h4 id="3-项目介绍"><a href="#3-项目介绍" class="headerlink" title="3. 项目介绍"></a>3. 项目介绍</h4><p>介绍或概括包括项目的目的和范围<br>示例：本文档的目标是测试“项目名称”的功能</p><h4 id="4-测试项目列表"><a href="#4-测试项目列表" class="headerlink" title="4. 测试项目列表"></a>4. 测试项目列表</h4><p>将要测试的测试项目列表<br>示例：测试应该在具体什么样的环境下的应用程序前台和后台进行。</p><h4 id="5-待测试的功能"><a href="#5-待测试的功能" class="headerlink" title="5. 待测试的功能"></a>5. 待测试的功能</h4><p>列出将在项目中测试的所有功能。<br>示例：要测试的功能包括登录页、仪表板、报表。</p><h4 id="6-未测试的功能"><a href="#6-未测试的功能" class="headerlink" title="6. 未测试的功能"></a>6. 未测试的功能</h4><p>我们将列出项目中未包含的功能。<br>示例：使用支付宝的支付将从应用程序中删除。无需测试此功能。</p><h4 id="7-实现方法"><a href="#7-实现方法" class="headerlink" title="7. 实现方法"></a>7. 实现方法</h4><p>如何执行测试的总体策略。它包含测试方法、测试类型、测试技术等详细信息。<br>示例：在这个项目中，我们遵循敏捷项目开发测试方法。</p><h4 id="8-合格-不合格标准"><a href="#8-合格-不合格标准" class="headerlink" title="8. 合格/不合格标准"></a>8. 合格/不合格标准</h4><p>指定用于确定测试项通过或失败百分比的标准。<br>示例：应用程序的所有主要功能都应按预期工作，测试用例的通过率应大于98%，自动化测试用例通过率100%，并且不应有任何严重的错误。</p><h4 id="9-暂停标准"><a href="#9-暂停标准" class="headerlink" title="9. 暂停标准"></a>9. 暂停标准</h4><p>将指定何时停止测试。<br>示例：如果任何主要功能不起作用或系统遇到登录问题，则应暂停测试。</p><h4 id="10-测试可交付成果"><a href="#10-测试可交付成果" class="headerlink" title="10. 测试可交付成果"></a>10. 测试可交付成果</h4><p>每个测试阶段需要交付的文档列表，所有测试的相关的文档和结果。<br>示例：测试用例、错误报告</p><h4 id="11-测试任务"><a href="#11-测试任务" class="headerlink" title="11. 测试任务"></a>11. 测试任务</h4><p>将指定在当前项目中需要完成的测试任务列表。<br>示例：测试环境应该在测试执行阶段之前准备好。需要准备测试总结报告。</p><h4 id="12-测试环境"><a href="#12-测试环境" class="headerlink" title="12. 测试环境"></a>12. 测试环境</h4><p>测试环境所需的硬件、软件和任何其他工具的列表。</p><h4 id="13-责任"><a href="#13-责任" class="headerlink" title="13. 责任"></a>13. 责任</h4><p>指定了每个测试任务的角色和职责列表。</p><h4 id="14-人员配置和培训需求"><a href="#14-人员配置和培训需求" class="headerlink" title="14. 人员配置和培训需求"></a>14. 人员配置和培训需求</h4><p>计划培训课程，以提高项目人员的技能，实现预期目标。</p><h4 id="15-日程安排"><a href="#15-日程安排" class="headerlink" title="15. 日程安排"></a>15. 日程安排</h4><p>完成关于何时开始、何时结束以及每项任务应进行多长时间的详细信息。<br>示例：执行测试执行–180工时，测试报告–20工时</p><h4 id="16-风险和突发情况"><a href="#16-风险和突发情况" class="headerlink" title="16. 风险和突发情况"></a>16. 风险和突发情况</h4><p>说明克服这些风险的风险和意外事件的可能性。<br>示例：风险-如果预算估计错误，则成本可能超支。应急计划-在测试任务开始前确定范围，并在项目规划中持续关注和更新动态，同时持续跟踪预算估计。</p><h4 id="17-批准"><a href="#17-批准" class="headerlink" title="17. 批准"></a>17. 批准</h4><p>谁应该签署并批准测试项目</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的测试计划可以让项目人员获得整个项目测试的整个框架和测试目标。不仅可以帮助到测试人员理清项目的测试内容和计划表，任务分配，技术需求，同时可以更具测试计划文档保证项目的测试顺利进行，产品正常交付。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件测试计划&quot;&gt;&lt;a href=&quot;#软件测试计划&quot; class=&quot;headerlink&quot; title=&quot;软件测试计划&quot;&gt;&lt;/a&gt;软件测试计划&lt;/h2&gt;&lt;p&gt;产品的开发需要文档，软件测试同样需要这样的文档。它包含了测试活动的内容，确保客户的需求被高质量的实现和交付。
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（五）软件测试中的测试可交付成果</title>
    <link href="https://xingyichuan.github.io/2019/10/24/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%9B%9B)%20%E6%B5%8B%E8%AF%95%E5%8F%AF%E4%BA%A4%E4%BB%98%E6%88%90%E6%9E%9C/"/>
    <id>https://xingyichuan.github.io/2019/10/24/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E5%9B%9B)%20%E6%B5%8B%E8%AF%95%E5%8F%AF%E4%BA%A4%E4%BB%98%E6%88%90%E6%9E%9C/</id>
    <published>2019-10-24T02:00:00.000Z</published>
    <updated>2019-12-04T15:22:18.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在整个产品研发的生命周期中，开发的交付成果就是整个产品，那么对于测试人员，会提供哪些可交付成果给整个项目呢？回答这个问题，我们需要把整个产品的研发生命周期拆分来看，对于每个阶段测试都会有相应的交付成果，有部分是在真正测试阶段之前交付的一些成果，有些则是在项目测试阶段完成之后交付的成果。</p><h2 id="测试可交付成果"><a href="#测试可交付成果" class="headerlink" title="测试可交付成果"></a>测试可交付成果</h2><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>每个产品的开发流程和生命周期可能会有些差异，所以在软件应用程序开发过程中，测试团队可能会准备不同的文档，以改善团队成员之间的沟通。这些文档也称为测试交付成果，因为它们与软件应用程序的最终产品一起交付给客户。</p><h4 id="测试可交付成果列表"><a href="#测试可交付成果列表" class="headerlink" title="测试可交付成果列表"></a>测试可交付成果列表</h4><ul><li><a href="https://segmentfault.com/a/1190000020793517" target="_blank" rel="noopener">测试策略文档</a></li><li><a href="https://segmentfault.com/a/1190000020812722" target="_blank" rel="noopener">测试计划文档</a></li><li>测试成本估算报告<br>  通常用户估算执行相关测试所需要的花费的人力和物力成本和时间</li><li>测试情境和剧本<br>  通常是按照功能需求文档衍生而来</li><li>测试用例和测试脚本</li><li>测试数据</li><li>需求跟踪测试阵列（RTM）<br>  用于检查测试用例和产品需求的覆盖程度</li><li><a href="https://segmentfault.com/a/1190000020852793" target="_blank" rel="noopener">缺陷报告</a></li><li>测试执行结果</li><li>产品质量监控图表和阵列</li><li>测试总结报告</li><li>严重问题的测试分析总结报告</li><li>测试阶段完成报告</li><li>产品发布记录</li><li>产品更新记录</li><li>安装和配置帮助指南</li><li>用户指导手册</li><li>测试状态更新报告</li><li>测试周报</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里只列举了常见的测试可交付成果，当然实际项目中可能会有其他测试可交付的成果。如果大家公司的测试人员还有其他的可交付成果，欢迎在留言区补充。谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在整个产品研发的生命周期中，开发的交付成果就是整个产品，那么对于测试人员，会提供哪些可交付成果给整个项目呢？回答这个问题，我们需要把整个产品
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（三）多种多样的测试类型</title>
    <link href="https://xingyichuan.github.io/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B8%89)%20%E5%A4%9A%E7%A7%8D%E5%A4%9A%E6%A0%B7%E7%9A%84%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xingyichuan.github.io/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B8%89)%20%E5%A4%9A%E7%A7%8D%E5%A4%9A%E6%A0%B7%E7%9A%84%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B/</id>
    <published>2019-10-22T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:35.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的《<a href="https://segmentfault.com/a/1190000020758481" target="_blank" rel="noopener">软件测试笔记（一）什么是软件测试-定义、类型、方法?</a>》中也曾经提高过测试的种类非常多，不同的术语往往让新人或者入行不久的测试人员望而生畏，对于开发也是同样的。这里推荐一个比较好的参考资料《<a href="https://www.istqb.org/downloads.html" target="_blank" rel="noopener">ISTQB认证的测试人员基础水平教学大纲</a>》，里面就包含了比较全面的测试术语还有测试方法。</p><p>在逐条介绍测试类型之前，让我们再次默念一遍软件测试的定义，对软件的功能进行评估，以确定所开发的软件是否满足规定的要求，通过发现缺陷，解决缺陷，来生产出高质量的产品的过程。</p><h2 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h2><h4 id="1-手工测试"><a href="#1-手工测试" class="headerlink" title="1.手工测试"></a>1.手工测试</h4><p>手工测试是通过手工测试软件,执行测试用例来发现缺陷的过程。通常测试人员是以最终用户的视角，并确保所有功能都按照需求客户需求实现。</p><h4 id="2-自动化测试"><a href="#2-自动化测试" class="headerlink" title="2.自动化测试"></a>2.自动化测试</h4><p>自动化测试是使用自动化工具，测试框架来测试软件的过程。在这个过程中，自动化工具会自动执行测试脚本并生成结果。一些最流行的自动化测试工具是test complete、selenium webdriver等。</p><h4 id="3-静态测试"><a href="#3-静态测试" class="headerlink" title="3.静态测试"></a>3.静态测试</h4><p>在软件测试中也称为验证。验证是检查文档和文件的静态方法。验证是一个过程，以确保我们创建的产品是否是正确的，即验证我们的需求。这里包括的活动有检查、审查、演练。</p><h4 id="4-动态测试"><a href="#4-动态测试" class="headerlink" title="4.动态测试"></a>4.动态测试</h4><p>同样也是也是一种验证, 测试真实产品的动态过程。同样也是以确保我们创建的产品是否是正确的。其中涉及的活动是测试应用程序。不同于上面的静态测试，而是更侧重于产品的功能。</p><h4 id="5-白盒测试"><a href="#5-白盒测试" class="headerlink" title="5.白盒测试"></a>5.白盒测试</h4><p>又称玻璃盒、透明盒、结构测试。白盒测试是基于应用程序内部的代码结构。在白盒测试中，是以系统的内部视角，以及需要相应的编程技巧来设计测试用例。这种测试通常在单元测试级别进行。</p><h4 id="6-基于代码结构的测试"><a href="#6-基于代码结构的测试" class="headerlink" title="6.基于代码结构的测试"></a>6.基于代码结构的测试</h4><p>请参考白盒测试。</p><h4 id="7-玻璃盒测试"><a href="#7-玻璃盒测试" class="headerlink" title="7.玻璃盒测试"></a>7.玻璃盒测试</h4><p>请参考白盒测试。</p><h4 id="8-透明盒测试"><a href="#8-透明盒测试" class="headerlink" title="8.透明盒测试"></a>8.透明盒测试</h4><p>请参考白盒测试。</p><h4 id="9-语句覆盖测试"><a href="#9-语句覆盖测试" class="headerlink" title="9.语句覆盖测试"></a>9.语句覆盖测试</h4><p>语句覆盖测试是一种白盒测试技术，用于验证代码中的每个语句是否至少执行一次。通常可以用语句覆盖率来检测单元测试的完成度。</p><h4 id="10-决策覆盖测试-分支覆盖测试"><a href="#10-决策覆盖测试-分支覆盖测试" class="headerlink" title="10.决策覆盖测试/分支覆盖测试"></a>10.决策覆盖测试/分支覆盖测试</h4><p>决策覆盖测试/分支覆盖测试：决策覆盖或分支覆盖测试是一种白盒测试技术，用于验证每个可能的分支至少执行一次。通常也可以用决策覆盖测试/分支覆盖测试率来检测单元测试的完成度。</p><h4 id="11-路径测试"><a href="#11-路径测试" class="headerlink" title="11.路径测试"></a>11.路径测试</h4><p>路径覆盖测试是一种白盒测试技术，用于验证程序的所有路径至少执行一次。通常也可以用路径覆盖测试率来检测单元测试的完成度。</p><h4 id="12-变异测试"><a href="#12-变异测试" class="headerlink" title="12.变异测试"></a>12.变异测试</h4><p>变异测试是一种白盒测试，它改变（变异）源代码中的某些语句，并验证测试是否能够找到错误。</p><h4 id="13-循环测试"><a href="#13-循环测试" class="headerlink" title="13.循环测试"></a>13.循环测试</h4><p>循环测试是一种白盒测试技术，用于验证不同类型的循环，如简单循环、嵌套循环、连接循环和非结构化循环。</p><h4 id="14-黑测试"><a href="#14-黑测试" class="headerlink" title="14.黑测试"></a>14.黑测试</h4><p>也称为基于设计文档的行为/规范/输入输出测试。黑盒测试是一种软件测试方法，在这种方法中，测试人员在不查看内部代码结构的情况下评估软件的功能。</p><h4 id="15-基于设计行为-规范-输入输出的测试"><a href="#15-基于设计行为-规范-输入输出的测试" class="headerlink" title="15.基于设计行为/规范/输入输出的测试"></a>15.基于设计行为/规范/输入输出的测试</h4><p>请参考黑盒测试。</p><h4 id="16-灰盒测试"><a href="#16-灰盒测试" class="headerlink" title="16.灰盒测试"></a>16.灰盒测试</h4><p>灰盒测试是介于黑盒和白盒测试之间的一种测试。测试人员需要访问开发设计文档，接口文档，从而来设计和执行相应的测试用例。</p><h4 id="17-功能测试"><a href="#17-功能测试" class="headerlink" title="17.功能测试"></a>17.功能测试</h4><p>简单地说，系统本身的功能其实就是一种功能测试。验证软件应用程序的每个功能是否按照需求文档中的规定运行。通过提供适当的输入来测试所有功能，以验证实际输出是否与预期输出匹配。它属于黑盒测试的范围，测试人员不必关心应用程序的源代码。</p><h4 id="18-非功能性测试"><a href="#18-非功能性测试" class="headerlink" title="18.非功能性测试"></a>18.非功能性测试</h4><p>简单地说，系统性能如何就是非功能性测试。非功能性测试是指软件的性能、负载、压力、可扩展性、安全性、兼容性等各个方面，主要关注的是提高用户体验系统对请求的响应速度。</p><h4 id="19-单元测试"><a href="#19-单元测试" class="headerlink" title="19.单元测试"></a>19.单元测试</h4><p>前面的白盒测试也提到了单元测试。单元测试是为了检查源代码的各个模块是否正常工作。即由开发人员在开发人员的环境中分别测试应用程序的每个单元。它也可以称之为模块测试或组件测试。</p><h4 id="20-模块测试"><a href="#20-模块测试" class="headerlink" title="20.模块测试"></a>20.模块测试</h4><p>请参考单元测试。</p><h4 id="21-组件测试"><a href="#21-组件测试" class="headerlink" title="21.组件测试"></a>21.组件测试</h4><p>请参考单元测试。</p><h4 id="22-集成测试"><a href="#22-集成测试" class="headerlink" title="22.集成测试"></a>22.集成测试</h4><p>集成测试是测试多个模块之间的连接或数据传输的过程。又称为I&amp;T （Integration Testing）测试或流测试。按照测试顺序，又分为自上而下法、自下而上法和夹心法（自上而下和自下而上相结合）。</p><h4 id="23-大爆炸集成测试（Big-bang-Integration-Testing）"><a href="#23-大爆炸集成测试（Big-bang-Integration-Testing）" class="headerlink" title="23.大爆炸集成测试（Big bang Integration Testing）"></a>23.大爆炸集成测试（<strong>Big bang Integration Testing</strong>）</h4><p>在完成单个模块测试后，将所有单元模块整体合并，并进行功能验证。</p><h4 id="24-自上而下的集成测试"><a href="#24-自上而下的集成测试" class="headerlink" title="24.自上而下的集成测试"></a>24.自上而下的集成测试</h4><p>首先测试高级模块，然后测试低级模块，最后将低级模块集成到高级模块，以确保系统按预期工作。如果模块未准备好进行集成测试，则可以用虚构(临时)模块代替。</p><h4 id="25-自下而上的集成测试"><a href="#25-自下而上的集成测试" class="headerlink" title="25.自下而上的集成测试"></a>25.自下而上的集成测试</h4><p>不同于自上而下的集成测试，测试是自下而上进行的。首先测试底层模块，然后测试高层模块，最后将高层模块集成到低层，以确保系统按预期工作。驱动程序用作集成测试的临时模块。</p><h4 id="26-混合集成测试"><a href="#26-混合集成测试" class="headerlink" title="26.混合集成测试"></a>26.混合集成测试</h4><p>混合集成测试是自顶向下和自下而上集成测试的结合。</p><h4 id="27-系统测试"><a href="#27-系统测试" class="headerlink" title="27.系统测试"></a>27.系统测试</h4><p>通常来说这是一个黑盒测试。测试完整的应用程序这也称为端到端的测试。确保软件在目标系统中可以正常工作。验证对不同的系统输入，同时检查所需的输出。测试用户对应用程序的体验。</p><h4 id="28-端到端测试"><a href="#28-端到端测试" class="headerlink" title="28.端到端测试"></a>28.端到端测试</h4><p>请参考系统测试。</p><h4 id="29-验收测试"><a href="#29-验收测试" class="headerlink" title="29.验收测试"></a>29.验收测试</h4><p>这是由最终用户和测试人员一起完成的，以验证应用程序的功能。验收测试成功后。为确定应用程序是否按要求开发而进行的正式测试。它允许客户接受或拒绝申请。验收测试的类型有alpha、beta和gamma。</p><h4 id="30-Alpha测试"><a href="#30-Alpha测试" class="headerlink" title="30.Alpha测试"></a>30.Alpha测试</h4><p>Alpha测试由内部开发人员（开发软件的人员）和测试人员完成。有时，Alpha测试是由客户或外包团队在开发人员或测试人员在场的情况下完成的。</p><h4 id="31-Beta测试"><a href="#31-Beta测试" class="headerlink" title="31.Beta测试"></a>31.Beta测试</h4><p>在产品交付前,由有限数量的最终用户测试完成。通常是在客户的环境中完成的测试。</p><h4 id="32-Gamma测试"><a href="#32-Gamma测试" class="headerlink" title="32.Gamma测试"></a>32.Gamma测试</h4><p>Gamma测试是在软件已经准备好按照指定的需求发布时完成的。同样的也是在客户的环境中完成。内部测试活动则完全不参与。</p><h4 id="33-等价划分法（等价类划分法）测试"><a href="#33-等价划分法（等价类划分法）测试" class="headerlink" title="33.等价划分法（等价类划分法）测试"></a>33.等价划分法（等价类划分法）测试</h4><p>等价划分也称为等价类划分。在等价划分中，软件的输入被划分为期望表现相似的组，因此可以将相似的输入归类。在测试中，从每个组中选择一个输入来设计测试用例。</p><h4 id="34-决策表（因果表）测试"><a href="#34-决策表（因果表）测试" class="headerlink" title="34.决策表（因果表）测试"></a>34.决策表（因果表）测试</h4><p>这种测试技术适用于输入之间具有逻辑关系的功能。在决策表技术中，我们处理输入的组合。为了识别带有决策表的测试用例，我们可以看它是否使用有条件的输入和操作结果作为输出。</p><h4 id="35-状态转换测试"><a href="#35-状态转换测试" class="headerlink" title="35.状态转换测试"></a>35.状态转换测试</h4><p>当应用程序为相同的输入提供不同的输出时，我们可以应用这个方法，这取决于在以前的状态中发生了什么。该测试的难点就是挑选出可以覆盖不同系统转换的应用程序的测试输入。</p><h4 id="36-穷举测试"><a href="#36-穷举测试" class="headerlink" title="36.穷举测试"></a>36.穷举测试</h4><p>使用所有有效和无效的输入和先决条件测试所有功能称为穷举测试。但是通常来说这种测试情况非常少。</p><h4 id="37-全匹配测试"><a href="#37-全匹配测试" class="headerlink" title="37.全匹配测试"></a>37.全匹配测试</h4><p>全匹配测试方法是用所有可能的输入参数值组合来测试应用程序，类似于穷举测试。</p><h4 id="38-正面测试"><a href="#38-正面测试" class="headerlink" title="38.正面测试"></a>38.正面测试</h4><p>它是为了确定系统应该做什么。它有助于检查应用程序是否符合要求。</p><h4 id="39-负面测试"><a href="#39-负面测试" class="headerlink" title="39.负面测试"></a>39.负面测试</h4><p>它是为了确定系统不应该做什么。它有助于从软件中发现缺陷。</p><h4 id="40-用例测试"><a href="#40-用例测试" class="headerlink" title="40.用例测试"></a>40.用例测试</h4><p>用例测试是在用例文档的帮助下进行的。它是用来帮助完成系统测试。</p><h4 id="41-场景（用户画像）测试"><a href="#41-场景（用户画像）测试" class="headerlink" title="41.场景（用户画像）测试"></a>41.场景（用户画像）测试</h4><p>场景测试是一种基于场景（用户画像）的软件测试技术。它涉及将业务需求转换为特定的测试场景，以便更好地理解和实现系统测试。一个设计良好的情景应该是合理的、可信的、复杂的，并且其结果易于评估。</p><h4 id="42-文档测试"><a href="#42-文档测试" class="headerlink" title="42.文档测试"></a>42.文档测试</h4><p>文档测试是为了验证文档化的文本，比如需求、测试计划、跟踪矩阵、测试用例。</p><h4 id="43-性能测试"><a href="#43-性能测试" class="headerlink" title="43.性能测试"></a>43.性能测试</h4><p>非常重要的测试类型，这类测试确定或验证被测系统或应用程序的速度、可伸缩性和/或稳定性特征。性能是指实现满足项目或产品性能目标的响应时间、吞吐量和资源利用率级别。</p><h4 id="44-负载测试"><a href="#44-负载测试" class="headerlink" title="44.负载测试"></a>44.负载测试</h4><p>验证系统/应用程序是否能够处理预期数量的事务，并验证系统/应用程序在正常和峰值负载条件下的行为。</p><h4 id="45-浸泡测试"><a href="#45-浸泡测试" class="headerlink" title="45.浸泡测试"></a>45.浸泡测试</h4><p>在高负载下长时间运行系统以识别性能问题称为浸泡测试。</p><h4 id="46-耐久性测试"><a href="#46-耐久性测试" class="headerlink" title="46.耐久性测试"></a>46.耐久性测试</h4><p>请参考浸泡测试。</p><h4 id="47-稳定性测试"><a href="#47-稳定性测试" class="headerlink" title="47.稳定性测试"></a>47.稳定性测试</h4><p>请参考浸泡测试。</p><h4 id="48-寿命测试"><a href="#48-寿命测试" class="headerlink" title="48.寿命测试"></a>48.寿命测试</h4><p>请参考浸泡试验。</p><h4 id="49-健壮性测试"><a href="#49-健壮性测试" class="headerlink" title="49.健壮性测试"></a>49.健壮性测试</h4><p>健壮性测试是为了验证应用程序的健壮性而进行的一种测试。不同于浸泡测试，它不需要有特别高的负载。</p><h4 id="50-可靠性测试"><a href="#50-可靠性测试" class="headerlink" title="50.可靠性测试"></a>50.可靠性测试</h4><p>对应用程序进行长时间的连续测试，以验证应用程序的稳定性</p><h4 id="51-可伸缩性测试"><a href="#51-可伸缩性测试" class="headerlink" title="51.可伸缩性测试"></a>51.可伸缩性测试</h4><p>可伸缩性测试是一种非功能性测试。它是为了确定被测应用程序如何随着工作负载的增加而动态的扩展。</p><h4 id="52-并发测试"><a href="#52-并发测试" class="headerlink" title="52.并发测试"></a>52.并发测试</h4><p>并发测试是指多个用户同时访问应用程序，以确保系统的稳定性。这主要用于识别死锁问题。</p><h4 id="53-破坏性测试"><a href="#53-破坏性测试" class="headerlink" title="53.破坏性测试"></a>53.破坏性测试</h4><p>破坏性测试是一种测试技术，其目的是通过持续测试直到应用程序崩溃来验证应用程序的健壮性。</p><h4 id="54-恢复测试"><a href="#54-恢复测试" class="headerlink" title="54.恢复测试"></a>54.恢复测试</h4><p>执行恢复测试是为了确定系统崩溃或硬件故障后系统恢复的速度。它属于非功能性测试。</p><h4 id="55-容量测试"><a href="#55-容量测试" class="headerlink" title="55.容量测试"></a>55.容量测试</h4><p>验证系统/应用程序是否能够处理大量数据。</p><h4 id="56-漏洞测试"><a href="#56-漏洞测试" class="headerlink" title="56.漏洞测试"></a>56.漏洞测试</h4><p>识别应用程序中的漏洞或弱点的测试过程。</p><h4 id="57-漏洞测试"><a href="#57-漏洞测试" class="headerlink" title="57.漏洞测试"></a>57.漏洞测试</h4><p>识别应用程序中的漏洞或弱点的测试过程。</p><h4 id="58-随机测试"><a href="#58-随机测试" class="headerlink" title="58.随机测试"></a>58.随机测试</h4><p>它是一种非正式的测试类型。测试人员在不遵循任何文档和测试设计技术的情况下随机测试应用程序。如果被测应用程序中的测试人员的知识非常丰富，则可以主要执行此测试。测试人员在没有任何测试用例或业务需求文档的情况下随机测试应用程序。</p><h4 id="59-探索性测试"><a href="#59-探索性测试" class="headerlink" title="59.探索性测试"></a>59.探索性测试</h4><p>通常，这个测试过程将由领域专家执行。他们仅仅通过探索应用程序的功能来执行测试，而不了解需求。</p><h4 id="60-猴子测试"><a href="#60-猴子测试" class="headerlink" title="60.猴子测试"></a>60.猴子测试</h4><p>故意对应用程序执行异常操作，就像是让一个猴子随意敲击键盘，以验证应用程序的稳定性。</p><h4 id="61-大猩猩测试"><a href="#61-大猩猩测试" class="headerlink" title="61.大猩猩测试"></a>61.大猩猩测试</h4><p>大猩猩测试是由测试人员完成的，有时开发人员也会与测试人员携手合作。它包括反复测试系统以测试系统的健壮性。</p><h4 id="62-重新测试"><a href="#62-重新测试" class="headerlink" title="62.重新测试"></a>62.重新测试</h4><p>确保在早期版本中发现并发布的缺陷在当前版本中得到修复或不被修复。</p><h4 id="63-回归测试"><a href="#63-回归测试" class="headerlink" title="63.回归测试"></a>63.回归测试</h4><p>对一个已经测试过的程序在修改后进行的重复测试，以发现由于被测试的软件或其他相关或不相关的软件组件的变化而引入或发现的任何缺陷。它区别于重新测试的是它不仅关注缺陷本身还关注修复缺陷带来的新的影响。</p><h4 id="64-健全性测试"><a href="#64-健全性测试" class="headerlink" title="64.健全性测试"></a>64.健全性测试</h4><p>健全性测试往往在发布阶段进行，以检查应用程序的主要功能，而不必深入。有时由于发布时间限制，无法对构建进行严格的回归测试，而健全测试则通过检查主要功能来完成这一部分。</p><h4 id="65-冒烟测试"><a href="#65-冒烟测试" class="headerlink" title="65.冒烟测试"></a>65.冒烟测试</h4><p>冒烟测试是为了确保构建的产品是否可测试。检查关键功能不起作用或关键错误尚未修复时，从而使用最少的时间来简单地测试整个应用程序。</p><h4 id="66-动态测试"><a href="#66-动态测试" class="headerlink" title="66.动态测试"></a>66.动态测试</h4><p>涉及对代码的执行和调试。它用预期的结果验证输出。</p><h4 id="67-可用性测试"><a href="#67-可用性测试" class="headerlink" title="67.可用性测试"></a>67.可用性测试</h4><p>验证应用程序是否对用户友好，用户使用是否流畅。一个好的应用程序应该是自我探索的，并且不需要培训就可以来使用它。</p><h4 id="68-可访问性测试"><a href="#68-可访问性测试" class="headerlink" title="68.可访问性测试"></a>68.可访问性测试</h4><p>可访问性测试是可用性测试的一个子集。它是针对于残疾人（如视觉障碍、身体障碍、听力障碍、认知障碍、学习障碍）如何容易地使用一个系统/应用程序。</p><h4 id="69-兼容性测试"><a href="#69-兼容性测试" class="headerlink" title="69.兼容性测试"></a>69.兼容性测试</h4><p>在不同的环境组件组合中部署并检查应用程序是否按预期工作。通常互联网的产品需要测试在不同的浏览器和设备是否可以正常访问。</p><h4 id="70-跨浏览器测试"><a href="#70-跨浏览器测试" class="headerlink" title="70.跨浏览器测试"></a>70.跨浏览器测试</h4><p>跨浏览器测试是一种非功能性测试，是兼容性测试的一部分，它帮助我们确保我们的网站或web应用程序在各种web浏览器中按预期工作。</p><h4 id="71-浏览器兼容性测试"><a href="#71-浏览器兼容性测试" class="headerlink" title="71.浏览器兼容性测试"></a>71.浏览器兼容性测试</h4><p>请参考跨浏览器测试。</p><h4 id="72-配置测试"><a href="#72-配置测试" class="headerlink" title="72.配置测试"></a>72.配置测试</h4><p>配置测试是使用每个受支持的硬件和软件配置测试应用程序的过程，以确定应用程序是否可以正常工作而不出现任何问题。通常在程序发布的时候，都会有个最低配置要求。作为测试人员，需要测试不同配置条件下系统/应用程序的表现。</p><h4 id="73-全球化测试"><a href="#73-全球化测试" class="headerlink" title="73.全球化测试"></a>73.全球化测试</h4><p>全球化是软件应用程序的设计的一个部分，目的是让它可以在不做任何更改的情况下适应不同的语言和地区。全球化测试则是针对于这部分的测试。</p><h4 id="74-国际化测试"><a href="#74-国际化测试" class="headerlink" title="74.国际化测试"></a>74.国际化测试</h4><p>请参考全球化测试。</p><h4 id="75-本地化测试"><a href="#75-本地化测试" class="headerlink" title="75.本地化测试"></a>75.本地化测试</h4><p>本地化是通过添加特定于本地化的组件（语言包），使全球化软件适应特定区域或语言的过程。通常会检查文字内容和系统样式内容。</p><h4 id="76-安全测试"><a href="#76-安全测试" class="headerlink" title="76.安全测试"></a>76.安全测试</h4><p>对于互联网公司来说，安全测试是一个非常重要的测试类型。安全测试是一个确定系统是否按预期保护数据和维护功能的过程。</p><h4 id="77-渗透测试"><a href="#77-渗透测试" class="headerlink" title="77.渗透测试"></a>77.渗透测试</h4><p>渗透测试是一种安全测试。它为了评估系统的安全性。</p><h4 id="78-模糊测试"><a href="#78-模糊测试" class="headerlink" title="78.模糊测试"></a>78.模糊测试</h4><p>模糊测试是安全测试的一种，用于识别应用程序中的编码错误和安全漏洞。通过向系统输入大量随机数据，试图使其崩溃，以确定应用程序中是否有任何中断。</p><h4 id="79-数据库测试"><a href="#79-数据库测试" class="headerlink" title="79.数据库测试"></a>79.数据库测试</h4><p>数据库测试是为了验证UI(用户界面)中的数据是否与数据库中存储的数据匹配。它包括检查数据库的模式(schema)、表、触发器等。</p><h4 id="80-后端测试"><a href="#80-后端测试" class="headerlink" title="80.后端测试"></a>80.后端测试</h4><p>其包含了数据库测试，同时还包括了服务器的测试，后台服务的测试等。</p><h4 id="81-桶（bucket）测试"><a href="#81-桶（bucket）测试" class="headerlink" title="81.桶（bucket）测试"></a>81.桶（bucket）测试</h4><p>桶(bucket)测试是一种将应用程序的两个版本进行比较以确定哪个版本性能更好的方法。</p><h4 id="82-A-B测试"><a href="#82-A-B测试" class="headerlink" title="82.A/B测试"></a>82.A/B测试</h4><p>类似于桶测试。</p><h4 id="83-区分-Split-测试"><a href="#83-区分-Split-测试" class="headerlink" title="83.区分(Split)测试"></a>83.区分(Split)测试</h4><p>类似于桶测试。</p><h4 id="84-图形用户界面测试"><a href="#84-图形用户界面测试" class="headerlink" title="84.图形用户界面测试"></a>84.图形用户界面测试</h4><p>图形用户界面测试是测试应用程序和最终用户之间的界面。测试人员主要关注的是外观元素如字体和颜色是否符合设计规范。</p><h4 id="85-UI测试"><a href="#85-UI测试" class="headerlink" title="85.UI测试"></a>85.UI测试</h4><p>在UI测试中，测试人员的目标是测试GUI和命令行界面（CLIs），同样参考图形用户界面测试。    </p><h4 id="86-接口测试"><a href="#86-接口测试" class="headerlink" title="86.接口测试"></a>86.接口测试</h4><p>执行接口测试以评估两个预期模块是否传递数据并相互正确通信。</p><h4 id="87-API测试"><a href="#87-API测试" class="headerlink" title="87.API测试"></a>87.API测试</h4><p>API代表应用程序编程接口。API测试是一种软件测试，包括使用postman等工具测试API。</p><h4 id="88-敏捷测试"><a href="#88-敏捷测试" class="headerlink" title="88.敏捷测试"></a>88.敏捷测试</h4><p>敏捷测试是一种包含以下敏捷软件开发方法原理的测试。在这种敏捷测试中，测试是在持续发展的项目的整个生命周期中进行的，而不是局限于特定的阶段。</p><h4 id="89-安装测试"><a href="#89-安装测试" class="headerlink" title="89.安装测试"></a>89.安装测试</h4><p>检查应用程序安装/卸载是否成功，安装后是否按预期工作，卸载后是否删除所有不需要的文件。</p><h4 id="90-正式测试"><a href="#90-正式测试" class="headerlink" title="90.正式测试"></a>90.正式测试</h4><p>测试人员通过预先计划好的程序和适当的文档来测试应用程序的过程。</p><h4 id="91-试运行测试"><a href="#91-试运行测试" class="headerlink" title="91.试运行测试"></a>91.试运行测试</h4><p>试运行测试是指公司为了获得客户的信任而在实时运行条件下进行的测试。</p><h4 id="92-前向兼容性测试"><a href="#92-前向兼容性测试" class="headerlink" title="92.前向兼容性测试"></a>92.前向兼容性测试</h4><p>前向兼容性测试是为了验证被测应用程序是否按照软件当前版本的更高版本的预期工作。</p><h4 id="93-向后兼容性测试"><a href="#93-向后兼容性测试" class="headerlink" title="93.向后兼容性测试"></a>93.向后兼容性测试</h4><p>向后兼容性测试是为了验证被测应用程序是否按照软件当前版本的早期版本的预期工作。</p><h4 id="94-向下兼容性测试"><a href="#94-向下兼容性测试" class="headerlink" title="94.向下兼容性测试"></a>94.向下兼容性测试</h4><p>请参考向后兼容性测试。</p><h4 id="95-合规性测试"><a href="#95-合规性测试" class="headerlink" title="95.合规性测试"></a>95.合规性测试</h4><p>合规性测试是一种非功能性测试，用于验证软件是否符合一组定义的标准。</p><h4 id="96-依赖性测试"><a href="#96-依赖性测试" class="headerlink" title="96.依赖性测试"></a>96.依赖性测试</h4><p>依赖性测试是检查应用程序对应用程序正常运行的前提条件、初始状态和配置的需求。</p><h4 id="97-众包测试（Crowdsourced-testing）"><a href="#97-众包测试（Crowdsourced-testing）" class="headerlink" title="97.众包测试（Crowdsourced testing）"></a>97.众包测试（Crowdsourced testing）</h4><p>众包测试是由一个由质量保证专家组成的社区通过一个在线平台进行的。</p><h4 id="98-ETL测试"><a href="#98-ETL测试" class="headerlink" title="98.ETL测试"></a>98.ETL测试</h4><p>ETL（extract，transform，load）测试包括验证从源到目的地的数据移动，验证源和目的地的数据量，验证数据提取、转换，以及验证表关系。</p><h4 id="99-数据仓库测试"><a href="#99-数据仓库测试" class="headerlink" title="99.数据仓库测试"></a>99.数据仓库测试</h4><p>请参阅ETL测试。</p><h4 id="100-故障注入测试"><a href="#100-故障注入测试" class="headerlink" title="100.故障注入测试"></a>100.故障注入测试</h4><p>故障注入测试是为了提高测试覆盖率而在代码中有意引入故障的测试技术。</p><h4 id="101-故障转移测试"><a href="#101-故障转移测试" class="headerlink" title="101.故障转移测试"></a>101.故障转移测试</h4><p>用于验证系统在服务器故障期间能够分配额外资源，并将处理部分任务传输到备份系统</p><h4 id="102-组队测试"><a href="#102-组队测试" class="headerlink" title="102.组队测试"></a>102.组队测试</h4><p>类似于组队开发的模式，通常有一个熟悉单元模块的测试和一个不熟悉该单元模块的测试，组队进行测试。</p><h4 id="103-基于风险的测试"><a href="#103-基于风险的测试" class="headerlink" title="103.基于风险的测试"></a>103.基于风险的测试</h4><p>确定最有可能导致故障的模块或功能，通常可以由开发和产品高阶使用人员给出相关的风险测试范围，然后测试这些功能。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上面列举了我所了解到的一些测试的种类，希望可以帮助大家抛开专业术语，了解其真实的测试内容。随着软件产品的多样化和测试技术的进步，上面列举的103种测试方法，肯定还有继续扩充的机会。如果大伙有什么补充请在留言回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前的《&lt;a href=&quot;https://segmentfault.com/a/1190000020758481&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（二）软件开发，测试，BUG的生命周期</title>
    <link href="https://xingyichuan.github.io/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%BA%8C)%20%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://xingyichuan.github.io/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%BA%8C)%20%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2019-10-22T02:00:00.000Z</published>
    <updated>2019-12-04T15:21:18.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>无论是产品的开发，软件的测试，还是BUG都会有属于自己的生命周期，了解了这些生命周期和它们之间的内在联系，可以让我们更好的理解软件，测试和缺陷管理，同时可以帮助梳理我们平时工作中的一些任务和其在不同生命周期的定位</p><h2 id="软件的开发生命周期（SDLC）"><a href="#软件的开发生命周期（SDLC）" class="headerlink" title="软件的开发生命周期（SDLC）"></a>软件的开发生命周期（SDLC）</h2><h5 id="什么是软件开发的生命周期？"><a href="#什么是软件开发的生命周期？" class="headerlink" title="什么是软件开发的生命周期？"></a>什么是软件开发的生命周期？</h5><p>软件项目中遵循的流程，以系统的方式开发产品并交付高质量的产品。通过遵循正确的软件开发流程，软件公司可以很好地应对市场压力并发布高质量的软件。</p><p>从需求阶段到部署和维护阶段，每个阶段都会产生生命周期下一个阶段所需的可交付成果。需求被转化为设计。根据设计生成代码。应根据要求对已开发的产品进行测试。测试完成后应立即进行部署。它的目的是创建一种高质量的系统，该系统可以满足或超出客户的期望，可以在当前和计划中的信息技术基础架构中有效且高效地工作，维护成本低廉，并且可以提高成本效益。下面就是一个标准的软件开发的生命周期图。</p><h5 id="软件开发的生命周期的意义？"><a href="#软件开发的生命周期的意义？" class="headerlink" title="软件开发的生命周期的意义？"></a>软件开发的生命周期的意义？</h5><p>可能有同学会有疑问了，即使没有这样一整套完整的软件开发的生命周期，我们也可以同样开发产品？</p><p>其原因有下面几点：</p><ul><li>它给产品的相关利益者提供了项目计划的可见性</li><li>同样可以帮助我们避免项目中会出现的一些风险</li><li>同第一点类似，它使我们能够跟踪和控制项目</li><li>因为每一个过程都会有可交付成果，所以我们可以保证每一个环节都是正确的，最终保证产品的顺利交付</li></ul><h5 id="软件开发的生命周期的每一个环节"><a href="#软件开发的生命周期的每一个环节" class="headerlink" title="软件开发的生命周期的每一个环节"></a>软件开发的生命周期的每一个环节</h5><ul><li><p>需求收集阶段<br>  需求收集和分析是软件开发生命周期中最重要的阶段。业务分析师根据客户的业务需求从客户/客户那里收集需求，并按照规范记录需求（文档名称因公司的定义而有所差异。例如，客户需求规范文档（CRS），业务规范文档（BS），等，并提供给开发团队。</p></li><li><p>需求定义阶段<br>  需求收集和分析完成后，下一步就是定义和记录产品需求，并获和客户沟通并且得到认可。这是通过SRS（软件需求规范文档）完成的。 文档中会包括在项目生命周期中要设计和开发的所有产品要求。此阶段涉及的关键人员是项目经理，业务分析师和团队的核心成员。此阶段的结果是软件需求规范。</p></li><li><p>产品设计阶段<br>  它有两层设计。第一层是产品的框架设计，它提供了要开发的软件产品的体系结构，由架构师和高级开发人员完成。第二层是定义产品中的每个功能应如何工作以及每个组件应如何工作，通常是接口设计。这些设计文档将作为下一个环节的输入。</p></li><li><p>产品研发阶段<br>  此阶段涉及所有开发人员。这是我们开始构建软件并开始为产品编写代码的阶段。此阶段的结果是源代码文档（SCD）和开发的产品。</p></li><li><p>产品测试阶段<br>  软件准备完成后，将其发送到测试部门，由测试团队针对各种缺陷对其进行全面测试。他们要么手动测试软件，要么使用自动测试工具，取决于STLC（软件测试生命周期）中定义的各个过程，并确保软件的每个组件都能正常运行，并且符合产品的需求文档。质量保证一旦确定软件没有错误，就进入下一阶段部署。这个阶段测试会对产品有个完整的质量评估。</p></li><li><p>产品研发阶段<br>  在成功测试之后，该产品将交付/部署给客户。部署由部署/实施工程师完成。一旦客户开始使用开发的系统，实际问题就会浮出水面，需要不时解决。解决客户发现的问题是在维护阶段。无法进行100％的测试-因为测试人员测试产品的方式与客户使用产品的方式不同。针对于这些问题，产品研发团队会通过补丁包或者更新版本来解决客户遇到的问题。</p></li></ul><h5 id="软件开发生命周期模型的类型："><a href="#软件开发生命周期模型的类型：" class="headerlink" title="软件开发生命周期模型的类型："></a>软件开发生命周期模型的类型：</h5><p>软件开发的生命周期的每一个环节和活动是固定的，针对于这些环节我们有不同的软件开发生命周期模型。比如说经典的瀑布模型和比较火热的敏捷开发流程，下面简单聊一下这两个模型。</p><ul><li><p>瀑布模型<br>  瀑布模型是传统和经典的模型。这是一种顺序设计过程，通常在SDLC中使用，在该过程中，进度被视为像瀑布一样自上而下的流动，经过需求收集，可行性研究/分析，设计，编码，测试，安装和维护等不同阶段。每个下一个阶段仅在完成上一个阶段的目标后才开始，并且相对独立。在与进度或成本相比质量更重要的项目中，首选此方法。这种方法最适合要求不变的短期项目。 </p></li><li><p>敏捷模型<br>  敏捷开发方法是非常流行开发方法之一。当然还有一些其他的敏捷开发方法，但广泛使用的常用方法是Scrum方法。Scrum方法是增量模型和迭代模型的组合，通常适用于项目需求经常变化的项目，和互联网项目。</p></li></ul><h2 id="什么是软件测试生命周期（STLC）"><a href="#什么是软件测试生命周期（STLC）" class="headerlink" title="什么是软件测试生命周期（STLC）"></a>什么是软件测试生命周期（STLC）</h2><p>软件测试生命周期（STLC）确定要执行的测试活动以及何时可以完成这些测试活动。尽管不同组织之间的测试有所不同，但都会存在一个测试生命周期。具体可以分为下面几个过程：</p><ul><li><p>需求分析阶段<br>  此阶段的进行依据是BRS（业务需求规范）文档。在此阶段，测试团队从测试的角度研究和分析产品的需求。此阶段有助于确定需求是否可测试。如果任何需求是不可测试的，测试团队可以在这个阶段与不同的部门（客户、业务分析师、技术主管、系统架构师等）进行沟通，以便可以规划缓解策略。</p><p>  可交付成果：所有可测试需求清单、自动化可行性报告，等</p></li><li><p>测试计划阶段<br>  这是真正测试过程的第一步。在这个阶段，测试经理/测试负责人通常需要确定整个项目的测试的工作量和成本估算。根据需求分析制定测试计划。在此阶段进行的活动，如资源统筹和规划、确定不同的测试角色和职责、工具选择（如果需要自动化）、测试的培训等。</p><p>  可交付成果：测试策略、测试计划和测试工作量估算文档。</p></li><li><p>测试设计阶段<br>  测试团队准备测试用例、测试脚本（如果需要自动化）和测试数据。一旦测试用例准备好，那么这些测试用例将由团队成员或团队领导进行设计用例评审。另外，测试团队准备需求跟踪矩阵（RTM）来保证测试用例可以覆盖需求并且验证是否满足需求。</p><p>  可交付成果：测试用例、测试脚本（如果需要自动化）、测试数据。</p></li><li><p>测试环境搭建阶段<br>  此阶段可以与测试设计阶段并行启动。根据硬件和软件需求表建立测试环境。在有些案例测试团队可能不参与这个阶段，开发团队或者由客户提供测试环境，当然取决于不同产品的性质和特点来定。同时，测试小组应准备冒烟测试用例，以检查给定测试环境的是否符合标准。</p><p>  可交付成果：可用的测试环境。冒烟测试结果符合预期。</p></li><li><p>测试环境搭建阶段<br>  测试团队开始基于计划的测试用例执行测试用例。如果测试用例的结果是通过/失败，那么应该在测试用例中记录相应的结果。为失败的测试用例准备缺陷报告，并应通过bug跟踪工具（如Jira）向开发团队报告缺陷。缺陷修复后将重新测试。</p><p>  可交付成果：测试用例执行报告、缺陷报告。</p></li><li><p>测试结果分析和产品评价阶段<br>  在此阶段我们将会准备测试最终报告，测试结果矩阵。测试团队召开会议，根据测试覆盖率、质量、时间、成本、软件、业务目标评估测试完成度。测试团队分析测试结果（如测试用例、缺陷报告等），以确定将来必须实施的策略，这将有助于消除即将到来的项目中的流程瓶颈。将根据上述标准编制测试度量和测试结束报告。</p><p>  可交付成果：测试最终报告、测试结果矩阵</p></li></ul><h2 id="什么是产品缺陷的生命周期（BLC-DLC）"><a href="#什么是产品缺陷的生命周期（BLC-DLC）" class="headerlink" title="什么是产品缺陷的生命周期（BLC,DLC）"></a>什么是产品缺陷的生命周期（BLC,DLC）</h2><p>缺陷生命周期是在软件开发过程中，bug也会有一个完整的生命周期。Bug应该经过什么样的生命周期才能关闭。 Bug生命周期的变化取决于所使用的工具（qc、jira等）和组织中遵循的缺陷管理过程。</p><h5 id="什么是一个BUG"><a href="#什么是一个BUG" class="headerlink" title="什么是一个BUG?"></a>什么是一个BUG?</h5><p>软件缺陷可以定义为软件的异常行为。怎么样定义异常行为，它可能是不符合我们的需求文档，软件本身的异常，比如产品的崩溃，性能差等问题。缺陷的生命周期是从发现缺陷时开始，在确保缺陷不被重现后，在缺陷关闭时结束。</p><h5 id="产品缺陷的生命周期的环节"><a href="#产品缺陷的生命周期的环节" class="headerlink" title="产品缺陷的生命周期的环节"></a>产品缺陷的生命周期的环节</h5><ul><li>创建缺陷<br>  当测试人员发现新的缺陷时。他应该向开发团队提供一份适当的缺陷文档，来帮助重现和修复缺陷。在此状态下，测试人员发布的缺陷状态为“创建”。</li><li>分配缺陷<br>  处于创建状态的缺陷将通常由测试负责人/项目负责人分配给开发团队。一旦分配了缺陷，缺陷的状态就变为“已分配”。</li><li>确认(打开)缺陷<br>  开发团队开始分析确认缺陷并开始修复工作。</li><li>解决缺陷<br>  当开发人员进行必要的代码更改并验证更改通过时，缺陷的状态将更改为“已修复”，缺陷将传递给测试团队。</li><li>待测试缺陷<br>  如果状态为“待测试”，则表示缺陷已修复并已经准备好测试是否已修复。需要开发提供必要的对应的产品版本信息或者是补丁。</li><li>验证缺陷<br>  在开发人员修复错误后，测试人员将重新验证该缺陷。如果在软件中没有检测到缺陷，将更改其状态为“已验证”。</li><li>关闭缺陷<br>  在验证通过后，那么bug的状态将被更改为“关闭”。 </li><li>重新打开缺陷<br>  如果缺陷在重新测试后，发现并没有修复，那么测试人员需要将缺陷状态更改为“重新打开”，需要再一次经过“修复”。    </li><li>重复缺陷<br>  如果缺陷重复了两或者多次，或者缺陷与缺陷的概念或者深层次的起因相同，开发团队将状态更改为“重复”。</li><li>延迟修复缺陷<br>  在某些情况下，项目经理/测试或者开发主管可能会将缺陷的状态设置为延迟。如果在发布结束时发现缺陷，并且该错误很小或不重要，通常会被建议到下一个版本中修复。或者客户有新的需求变更，通常也会将缺陷状态更改为“延迟修复”，并将在下一版本中修复。</li><li>拒绝修复缺陷<br>  如果系统是按照需求文档实现的，而缺陷仅仅是由于一些误解（例如使用了旧的需求或未定义的特性）造成的，那么团队领导或开发人员可以将这些错误标记为“拒绝修复”。</li></ul><p>当然这里还有一些其他的环节比如说：</p><ul><li>无法解决的缺陷：<br>  技术无法支持，产品架构设计的缺陷，解决缺陷的成本过高。</li><li>无法重现的缺陷：<br>  测试环境不匹配、错误的缺陷文档、数据的不匹配、软件版本不匹配，等原因引起的缺陷</li><li>需要更多信息的缺陷：<br>  如果开发人员无法按照测试人员提供的步骤来重现缺陷，那么开发人员可以将状态更改为“需要更多信息”。在这种情况下，测试人员需要添加详细的重现步骤，并将bug再次分配给开发团队进行修复。如果测试人员编写了一个好的缺陷文档，通常就不会发生这种情况。 </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里大概的介绍了产品研发，软件测试和缺陷的生命周期。这里有助于我们理解测试在整个产品研发生命周期的定位，同时也可以帮助理解测试生命周期的每一个环节，来定义我们每一测试环节的需要和输出，帮助我们更好的进行测试，来提高产品的质量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h2&gt;&lt;p&gt;无论是产品的开发，软件的测试，还是BUG都会有属于自己的生命周期，了解了这些生命周期和它们之间的内在联系，可以让我们更好的理
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记（一）什么是软件测试-定义、类型、方法?</title>
    <link href="https://xingyichuan.github.io/2019/10/21/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B8%80)%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>https://xingyichuan.github.io/2019/10/21/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%20(%E4%B8%80)%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2019-10-21T02:34:12.000Z</published>
    <updated>2019-12-04T15:22:25.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么我们需要软件测试？"><a href="#为什么我们需要软件测试？" class="headerlink" title="为什么我们需要软件测试？"></a>为什么我们需要软件测试？</h2><p>可能有些人会有这样的疑问：“为什么我们需要软件测试”或者“为什么需要测试”或者“为什么需要软件测试”。</p><p>当我进入测试行业的时候，我不知道什么是软件测试以及为什么需要它。我也不知道从哪里开始。也许你的处境和我很久以前一样。就我而言，软件测试是一门艺术，它评估软件应用程序的功能，目的是发现开发的软件是否满足指定的要求，并确定缺陷，以确保产品无缺陷（理想状态），从而生产出高质量的产品。</p><p><strong>假设如果在软件开发过程中没有软件测试呢？</strong></p><p>按照目前的趋势，由于数字化的不断变化和发展，我们的生活在各个方面都在改善。我们的工作方式也改变了。我们在网上访问我们的银行，在网上购物，在网上订购食物等等。我们依赖软件和系统。如果这些系统出现故障怎么办。我们都知道，从财务损失和商誉的角度来看，一个小漏洞对企业的影响是巨大的。为了交付高质量的产品，我们需要在软件开发过程中进行软件测试。</p><p>软件测试之所以成为信息技术领域非常重要和不可或缺的一部分，原因如下。</p><ul><li><p>成本效益<br>事实上，对于任何复杂的系统，设计缺陷永远不能完全排除。这并不是因为开发人员粗心大意，而是因为系统的复杂性是通常是难以处理的。如果设计级别的问题未被发现，那么追溯和纠正缺陷将变得更加困难。解决它会变得更贵。有时在修复一个错误时，我们可能会不知不觉地在另一个模块中引入另一个错误，这就需要我们进行回归测试。如果可以在开发的早期阶段识别出这些错误（bug），那么修复它们的成本就要低得多。这就是为什么在软件开发生命周期的早期阶段发现缺陷是很重要的。测试的好处之一是成本效益。</p><p>在软件开发生命周期的各个阶段，最好尽早开始测试，并定期测试，以确保应用程序的开发符合要求。</p></li><li><p>顾客满意度<br>在任何企业中，最终的目标都是让顾客满意，顾客就是上帝。顾客满意是非常重要！！！软件测试改善了应用程序的用户体验，并使客户满意。快乐的顾客意味着企业有更多的收入。有必要进行软件测试的原因之一是提供最佳的用户体验。</p></li><li><p>安全<br>这可能是软件测试中最敏感和最脆弱的部分。测试（渗透测试和安全测试）有助于产品安全。黑客未经授权获取数据，例如facebook的个人隐私数据的泄露，还有国内的一些知名网站的关于身份证，手机号，家庭住址等等信息的泄露。黑客窃取用户信息并将其用于自身利益，或者售卖给不法买家，损害使用产品的顾客，这绝对不是我们想要看到的结果。如果你的产品不安全，用户就不会喜欢你的产品。用户总是寻找值得信赖的产品。测试有助于消除产品中的漏洞。</p></li><li><p>产品质量<br>软件测试是一门艺术，它有助于加强一个公司的市场声誉，通过交付高质量的产品给客户所提到的需求规格文件。</p><p>由于这些原因，软件测试成为软件开发过程中非常重要和不可或缺的一部分。</p></li></ul><h2 id="回到最本质的问题-什么是软件测试？"><a href="#回到最本质的问题-什么是软件测试？" class="headerlink" title="回到最本质的问题, 什么是软件测试？"></a>回到最本质的问题, 什么是软件测试？</h2><p>软件测试是一个过程，旨在评估软件应用程序的功能，以确定开发的软件是否满足指定的要求，并确定缺陷，以确保产品无缺陷，从而生产出高质量的产品。</p><h2 id="软件测试种类："><a href="#软件测试种类：" class="headerlink" title="软件测试种类："></a>软件测试种类：</h2><ul><li><p>手工测试：<br>手工测试是手工测试软件的过程，以了解更多关于它的信息，找出什么是工作的，什么是不工作的。这通常包括验证需求文档中指定的所有特性，但通常也包括测试人员从最终用户的角度尝试软件。手动测试计划从完全脚本化的测试用例、为测试人员提供详细的步骤和预期的结果，到指导探索性测试会话的高级指南，各不相同。市场上有很多复杂的工具来帮助手工测试，但是如果你想要一个简单而灵活的地方开始，可以尝试使用下POSTMAN.</p></li><li><p>自动化测试：<br>自动化测试是使用自动化工具来发现软件缺陷的测试过程。在此过程中，测试人员使用自动化工具执行测试脚本并自动生成测试结果。功能测试的一些著名自动化测试工具是qtp/uft和selenium。</p></li></ul><h2 id="按照测试的具体内容来分的测试方法："><a href="#按照测试的具体内容来分的测试方法：" class="headerlink" title="按照测试的具体内容来分的测试方法："></a>按照测试的具体内容来分的测试方法：</h2><ul><li><p>静态测试：<br>在软件测试中也称为验证。验证是检查文档和文件的静态方法。验证是一个过程，以确保我们创建的产品是否是正确的，即验证我们的需求。这里包括的活动有检查、审查、演练。</p></li><li><p>动态测试：<br>同样也是也是一种验证, 测试真实产品的动态过程。同样也是以确保我们创建的产品是否是正确的。其中涉及的活动是测试应用程序。不同于上面的静态测试，而是更侧重于产品的功能。</p></li></ul><h2 id="按照是否需要接触功能代码来分的测试方法分类："><a href="#按照是否需要接触功能代码来分的测试方法分类：" class="headerlink" title="按照是否需要接触功能代码来分的测试方法分类："></a>按照是否需要接触功能代码来分的测试方法分类：</h2><ul><li><p>白盒测试：<br>又称玻璃盒、透明盒、结构测试。白盒测试是基于应用程序内部的代码结构。在白盒测试中，是以系统的内部视角，以及需要相应的编程技巧来设计测试用例。这种测试通常在单元测试级别进行。</p></li><li><p>黑盒测试：<br>也称为基于设计文档的行为/规范/输入输出测试。黑盒测试是一种软件测试方法，在这种方法中，测试人员在不查看内部代码结构的情况下评估软件的功能。</p></li></ul><p>黑盒测试同时可以分为两种测试：</p><ul><li><p>功能测试：<br>简单地说，系统本身的功能其实就是一种功能测试。验证软件应用程序的每个功能是否按照需求文档中的规定运行。通过提供适当的输入来测试所有功能，以验证实际输出是否与预期输出匹配。它属于黑盒测试的范围，测试人员不必关心应用程序的源代码。</p></li><li><p>非功能测试：<br>简单地说，系统性能测试就是非功能性测试。非功能性测试是指软件的性能、负载、压力、可扩展性、安全性、兼容性等各个方面，主要关注的是提高用户体验系统对请求的响应速度。<br>灰盒测试：灰盒测试是白盒测试和黑盒测试的结合。从事此类测试的测试人员需要访问产品的设计和接口文档，来创建更好的测试用例。</p></li></ul><p>无论您是黑盒、白盒还是灰盒测试人员，都需要维护测试用例。</p><h2 id="按照是测试级别的测试方法分类："><a href="#按照是测试级别的测试方法分类：" class="headerlink" title="按照是测试级别的测试方法分类："></a>按照是测试级别的测试方法分类：</h2><ul><li><p>单元测试：<br>前面的白盒测试也提到了单元测试。单元测试是为了检查源代码的各个模块是否正常工作。即由开发人员在开发人员的环境中分别测试应用程序的每个单元。它也可以称之为模块测试或组件测试。</p></li><li><p>集成测试：<br>集成测试是测试多个模块之间的连接或数据传输的过程。又称为I&amp;T （Integration Testing）测试或流测试。按照测试顺序，又分为自上而下法、自下而上法和夹心法（自上而下和自下而上相结合）。</p></li><li><p>系统测试（端到端测试）：<br>通常来说这是一个黑盒测试。测试完整的应用程序这也称为端到端的测试。确保软件在目标系统中可以正常工作。验证对不同的系统输入，同时检查所需的输出。测试用户对应用程序的体验。</p></li><li><p>验收测试：<br>这是由最终用户和测试人员一起完成的，以验证应用程序的功能。验收测试成功后。为确定应用程序是否按要求开发而进行的正式测试。它允许客户接受或拒绝申请。验收测试的类型有alpha、beta和gamma。</p></li></ul><h2 id="测试产出："><a href="#测试产出：" class="headerlink" title="测试产出："></a>测试产出：</h2><p>交付给软件项目的可交付成果。针对于遵循产品生命周期，也就是在交付给客户之前经历了不同的阶段，每个阶段都会有一些测试可交付成果。一些可交付成果在测试阶段开始前提供，一些在测试阶段提供，其余在测试阶段完成后提供。</p><p>一些测试可交付成果如下：</p><ul><li>测试计划</li><li>测试（跟踪）矩阵</li><li>测试用例</li><li>测试脚本</li><li>测试套件（测试合集）</li><li>测试数据或测试准备数据</li><li>测试实验工具</li></ul><h2 id="测试的原则："><a href="#测试的原则：" class="headerlink" title="测试的原则："></a>测试的原则：</h2><p>软件测试包括一些在测试项目时起着重要作用的原则。</p><p>软件测试的原则如下：</p><ul><li>测试可重现的缺陷</li><li>彻底的测试是不可能的</li><li>尽早早测试</li><li>缺陷归类</li><li>农药悖论 （用来描述这样一种现象，对软件进行越多的测试，那么该软件对软件测试人员的测试就越具有免疫力，对于测试人员需要转换测试思路来发现新的问题。）</li><li>测试是依赖于上下文的</li><li>系统或多或少会存在bug</li><li>阅读更多：详细说明文档</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>上面介绍了软件测试的意义，定义，以及常用的测试方法和类型，当然实际的测试种类会更多（大约有一百多种）。</p><p>有机会的话，在以后的博客中，给大家更新下着一百多种测试类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么我们需要软件测试？&quot;&gt;&lt;a href=&quot;#为什么我们需要软件测试？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们需要软件测试？&quot;&gt;&lt;/a&gt;为什么我们需要软件测试？&lt;/h2&gt;&lt;p&gt;可能有些人会有这样的疑问：“为什么我们需要软件测试”或者“为
      
    
    </summary>
    
    
      <category term="测试" scheme="https://xingyichuan.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试理论" scheme="https://xingyichuan.github.io/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
</feed>
